---
title:  perfbook-c15-é™„å½•C
layout: post
categories: perfbook
tags: perfbook å¹¶è¡Œç¼–ç¨‹ ä¹¦ç± å†…å­˜åº å¹¶å‘æ§åˆ¶
excerpt: perfbook-c15-é™„å½•C
---
# 15 Advanced Synchronization: Memory Ordering
## 15.1 Ordering: Why and How?
**ä¾‹1**
ä»¥ä¸‹è¿™ä¸ªä¾‹å­åœ¨å„ä¸ªå¹³å°ä¸‹éƒ½å¯ä»¥è§¦å‘`exists`ï¼ŒåŒ…æ‹¬x86ã€‚

```C
/* C-SB+o-o+o-o.litmus */
P0(int *x0, int *x1)
{
    int r2;

    WRITE_ONCE(*x0, 2);
    r2 = READ_ONCE(*x1);
}


P1(int *x0, int *x1)
{
    int r2;

    WRITE_ONCE(*x1, 2);
    r2 = READ_ONCE(*x0);
}

exists (1:r2=0 /\ 0:r2=0)

```

### 15.1.1 Why Hardware Misordering?

![QrvbrV.png](https://s2.ax1x.com/2019/12/11/QrvbrV.png)

è§£é‡Šäº†ä¸Šè¿°çš„ä¾‹å­ä¸­æ˜¯å¦‚ä½•å‡ºç°`exists (1:r2=0 /\ 0:r2=0)`è¿™ä¸€ç»“æœçš„ã€‚

æ³¨æ„åˆ°ç¬¬`4`è¡Œï¼Œåœ¨`CPU0`å’Œ`CPU1`åŒæ—¶å‘å‡º`read-invalidate`æ¶ˆæ¯ä¹‹åï¼Œä¸¤ä¸ª`CPU`ä¼šäº¤æ¢`cacheline`ã€‚

æœ€åå†å°†`store buffer`ä¸­çš„å€¼å†™å…¥åˆ°æ–°å¾—åˆ°çš„`cacheline`ä¸­ã€‚

### 15.1.2 How to Force Ordering?
**ä¾‹2**
```C
P0(int *x0, int *x1)
{
	int r2;

	WRITE_ONCE(*x0, 2);
	smp_mb();	
	r2 = READ_ONCE(*x1);
}


P1(int *x0, int *x1)
{
	int r2;

	WRITE_ONCE(*x1, 2);
	smp_mb();	
	r2 = READ_ONCE(*x0);
}

exists (1:r2=0 /\ 0:r2=0)

```

ä»¥ä¸‹ä¸º`exists (1:r2=2 /\ 0:r2=2)`çš„æ—¶åºï¼š

![Qrzfpj.png](https://s2.ax1x.com/2019/12/11/Qrzfpj.png)

ä»¥ä¸‹ä¸ºlinuxå†…æ ¸ä¸­å†…å­˜åºç›¸å…³çš„åŸè¯­ï¼š

![Qspiq0.png](https://s2.ax1x.com/2019/12/11/Qspiq0.png)

15.1.3 Basic Rules of Thumb

## 15.2 Tricks and Traps
15.2.1 Variables With Multiple Values
15.2.2 Memory-Reference Reordering
15.2.3 Address Dependencies
15.2.4 Data Dependencies
15.2.5 Control Dependencies
15.2.6 Cache Coherence
15.2.7 Multicopy Atomicity

15.3 Compile-Time Consternation
15.3.1 Memory-Reference Restrictions
15.3.2 Address- and Data-Dependency Diculties
15.3.3 Control-Dependency Calamities
15.4 Hardware Specifics
15.4.1 Alpha
15.4.2 ARMv7-A/R
15.4.3 ARMv8
15.4.4 Itanium
15.4.5 MIPS
15.4.6 POWER / PowerPC
15.4.7 SPARC TSO
15.4.8 x86
15.4.9 z Systems
15.5 Where is Memory Ordering Needed?



# Appendix C Why Memory Barriers?
## C.1 Cache Structure
å½“ä¸€ä¸ªç‰¹å®šçš„æ•°æ®é¡¹åˆæ¬¡è¢«CPUè®¿é—®æ—¶ï¼Œå®ƒåœ¨ç¼“å­˜ä¸­è¿˜ä¸å­˜åœ¨ï¼Œè¿™ç§°ä¸ºâ€œç¼“å­˜ç¼ºå¤±â€(`cache miss`)ã€‚

ç»è¿‡ä¸€æ®µæ—¶é—´åï¼ŒCPUçš„ç¼“å­˜å°†è¢«å¡«æ»¡ï¼Œåç»­çš„ç¼“å­˜ç¼ºå¤±å¾ˆå¯èƒ½éœ€è¦æ¢å‡ºç¼“å­˜ä¸­ç°æœ‰çš„æ•°æ®ï¼Œä»¥ä¾¿ä¸ºæœ€è¿‘çš„è®¿é—®é¡¹è…¾å‡ºç©ºé—´ã€‚è¿™ç§â€œç¼“å­˜ç¼ºå¤±â€è¢«ç§°ä¸ºâ€œå®¹é‡ç¼ºå¤±â€(`capacity miss`)ï¼Œå› ä¸ºå®ƒæ˜¯ç”±äºç¼“å­˜å®¹é‡é™åˆ¶è€Œé€ æˆçš„ã€‚

ä½†æ˜¯ï¼Œå³ä½¿æ­¤æ—¶ç¼“å­˜è¿˜æ²¡æœ‰è¢«å¡«æ»¡ï¼Œå¤§é‡ç¼“å­˜ä¹Ÿå¯èƒ½ç”±äºä¸€ä¸ªæ–°æ•°æ®è€Œè¢«æ¢å‡ºã€‚è¿™æ˜¯ç”±äºå¤§å®¹é‡ç¼“å­˜æ˜¯é€šè¿‡ç¡¬ä»¶å“ˆå¸Œè¡¨æ¥å®ç°çš„ã€‚

å› æ­¤ï¼Œåœ¨ä¸€ä¸ªç‰¹å®šçš„CPUå†™æ•°æ®å‰ï¼Œè®©æ‰€æœ‰CPUéƒ½æ„è¯†åˆ°æ•°æ®è¢«ä¿®æ”¹è¿™ä¸€ç‚¹æ˜¯éå¸¸é‡è¦çš„ï¼Œå› æ­¤ï¼Œå®ƒå¿…é¡»é¦–å…ˆä»å…¶ä»–CPUçš„ç¼“å­˜ä¸­ç§»é™¤ï¼Œæˆ–è€…å«â€œä½¿æ— æ•ˆâ€(`invalidated`)ã€‚

ä¸€æ—¦â€œä½¿æ— æ•ˆâ€æ“ä½œå®Œæˆï¼ŒCPUå¯ä»¥å®‰å…¨çš„ä¿®æ”¹æ•°æ®é¡¹ã€‚å¦‚æœæ•°æ®å­˜åœ¨äºè¯¥CPUç¼“å­˜ä¸­ï¼Œä½†æ˜¯æ˜¯åªè¯»çš„ï¼Œè¿™ä¸ªè¿‡ç¨‹ç§°ä¸ºâ€œå†™ç¼ºå¤±â€(`write miss`)ã€‚

éšåï¼Œå¦‚æœå¦å¤–æŸä¸ªCPUè¯•å›¾è®¿é—®æ•°æ®é¡¹ï¼Œå°†ä¼šå¼•èµ·ä¸€æ¬¡ç¼“å­˜ç¼ºå¤±ï¼Œæ­¤æ—¶ï¼Œç”±äºç¬¬ä¸€ä¸ªCPUä¸ºäº†å†™è€Œä½¿å¾—ç¼“å­˜é¡¹æ— æ•ˆï¼Œè¿™ç§ç±»å‹çš„ç¼“å­˜ç¼ºå¤±è¢«ç§°ä¸ºâ€œé€šä¿¡ç¼ºå¤±â€(`communication miss`)ã€‚

> æˆ‘çš„å°é—®é¢˜:`write miss`å’Œ`communication miss`çš„åŒºåˆ«æ˜¯ä»€ä¹ˆï¼Ÿ
`write miss`çš„å®šä¹‰ï¼šå¦‚æœæ•°æ®å­˜åœ¨äºè¯¥CPUç¼“å­˜ä¸­ï¼Œä½†æ˜¯æ˜¯åªè¯»çš„ï¼Œè¿™ä¸ªè¿‡ç¨‹ç§°ä¸ºâ€œå†™ç¼ºå¤±â€(`write miss`)ã€‚  
è¿™çœ‹èµ·æ¥æ›´åƒæ˜¯ä¸€ç§çŠ¶æ€ã€‚  
è€Œ`communication miss`æ˜¯ä¸€ç§äº‹ä»¶ã€‚

## C.2 Cache-Coherence Protocols
è¯¦è§åŸæ–‡ã€‚

> æˆ‘çš„å°é—®é¢˜ï¼šå¦‚ä½•ç†è§£`read invalidate`æ¶ˆæ¯ï¼Ÿ

ç­”æ¡ˆï¼šWhen the CPU does an atomic readmodify-write operation on a data item that was not present in its cache. It transmits a â€œread invalidateâ€, receiving the data via a â€œread responseâ€.  
At the same time, the CPU can complete the transition of MESI status once it has also received a full set of â€œinvalidate acknowledgeâ€ responses.  
ç›¸å½“äºæŠŠä¸€ä¸ªå˜é‡çš„æ‰€æœ‰æƒä»å…¶ä»–CPUä¸­å¤ºäº†è¿‡æ¥ï¼Œä¸æ’ä»–è¯»çš„è¯­ä¹‰ç›¸è¿‘ã€‚

## C.3 Stores Result in Unnecessary Stalls

![MfL474.png](https://s2.ax1x.com/2019/11/20/MfL474.png)

### C.3.1 Store Buffers

é¿å…è¿™ç§ä¸å¿…è¦çš„å†™åœé¡¿çš„æ–¹æ³•ä¹‹ä¸€ï¼Œæ˜¯åœ¨æ¯ä¸ªCPUå’Œå®ƒçš„ç¼“å­˜ä¹‹é—´ï¼Œå¢åŠ `store buffer`ï¼Œå¦‚å›¾C.5ã€‚é€šè¿‡å¢åŠ è¿™äº›`store buffer`åŒºï¼ŒCPU 0å¯ä»¥ç®€å•åœ°å°†è¦ä¿å­˜çš„æ•°æ®æ”¾åˆ°`store buffer`åŒºä¸­ï¼Œå¹¶ä¸”ç»§ç»­è¿è¡Œã€‚å½“ç¼“å­˜è¡Œæœ€ç»ˆä»CPU1è½¬åˆ°CPU0æ—¶ï¼Œæ•°æ®å°†ä»å­˜å‚¨ç¼“å†²åŒºè½¬åˆ°ç¼“å­˜è¡Œä¸­ã€‚

![MfLqc6.png](https://s2.ax1x.com/2019/11/20/MfLqc6.png)

### C.3.2 Store Forwarding

æ¯ä¸ªCPUåœ¨æ‰§è¡ŒåŠ è½½æ“ä½œæ—¶ï¼Œå°†å…ˆä»`store buffer`ä¸­è·å–ï¼Œå¦‚å›¾`C.6`ã€‚æ¢å¥è¯è¯´ï¼Œä¸€ä¸ªç‰¹å®šçš„CPUå­˜å‚¨æ“ä½œç›´æ¥è½¬å‘ç»™åç»­çš„è¯»æ“ä½œï¼Œè€Œå¹¶ä¸å¿…ç„¶ç»è¿‡å…¶ç¼“å­˜ã€‚

![MfO8DU.png](https://s2.ax1x.com/2019/11/20/MfO8DU.png)

### C.3.3 Store Buffers and Memory Barriers

å†…å­˜å±éšœ`smp_mb`å°†å¯¼è‡´CPUåœ¨åˆ·æ–°`store buffer`ä¸­åç»­çš„`store`æ“ä½œåˆ°`cacheline`ä¹‹å‰ï¼Œå‰é¢çš„`store`æ“ä½œå…ˆè¢«åˆ·æ–°ã€‚

## C.4 Store Sequences Result in Unnecessary Stalls

ä¸å¹¸çš„æ˜¯ï¼Œæ¯ä¸€ä¸ª`store buffer`ç›¸å¯¹è€Œè¨€éƒ½æ¯”è¾ƒå°ï¼Œè¿™æ„å‘³ç€æ‰§è¡Œä¸€æ®µè¾ƒå°çš„å­˜å‚¨æ“ä½œåºåˆ—çš„CPUï¼Œå°±å¯èƒ½å¡«æ»¡å®ƒçš„`store buffer`ï¼ˆä¾‹å¦‚ï¼Œå½“æ‰€æœ‰`store`æ“ä½œéƒ½å‘ç”Ÿäº†`cache misses`æ—¶ï¼‰ã€‚ä»è¿™ä¸€ç‚¹æ¥çœ‹ï¼ŒCPUåœ¨èƒ½å¤Ÿç»§ç»­æ‰§è¡Œå‰ï¼Œå¿…é¡»å†æ¬¡ç­‰å¾…åˆ·æ–°æ“ä½œå®Œæˆï¼Œå…¶ç›®çš„æ˜¯ä¸ºäº†æ¸…ç©ºå®ƒçš„`store buffer`ã€‚

ç›¸åŒçš„æƒ…å†µå¯èƒ½åœ¨å†…å­˜å±éšœä¹‹åå‘ç”Ÿï¼Œå†…å­˜å±éšœä¹‹åçš„æ‰€æœ‰`store`æ“ä½œæŒ‡ä»¤ï¼Œéƒ½å¿…é¡»ç­‰å¾…åˆ·æ–°æ“ä½œå®Œæˆï¼Œè€Œä¸ç®¡è¿™äº›åç»­`store`æ˜¯å¦å­˜åœ¨ç¼“å­˜ç¼ºå¤±ã€‚

è¿™å¯ä»¥é€šè¿‡ä½¿`invalidate acknowledge messages`æ›´å¿«åˆ°è¾¾CPUæ¥åˆ°å¾—åˆ°æ”¹å–„ã€‚


### C.4.1 Invalidate Queues

åœ¨å‘é€åº”ç­”å‰ï¼ŒCPU ä¸å¿…çœŸæ­£ä½¿æ— æ•ˆç¼“å­˜è¡Œã€‚å®ƒå¯ä»¥å°†ä½¿æ— æ•ˆæ¶ˆæ¯å…¥é˜Ÿåˆ—ã€‚  
å¦‚ä¸‹å›¾æ‰€ç¤º:  
![MfXZM6.png](https://s2.ax1x.com/2019/11/20/MfXZM6.png)

### C.4.2 Invalidate Queues and Invalidate Acknowledge

CPUå¿…é¡»åœ¨å‡†å¤‡å‘é€ä½¿æ— æ•ˆæ¶ˆæ¯å‰ï¼Œå¼•ç”¨å®ƒçš„ä½¿æ— æ•ˆé˜Ÿåˆ—ã€‚

å¦‚æœä¸€ä¸ªç¼“å­˜è¡Œç›¸åº”çš„æ¡ç›®åœ¨ä½¿æ— æ•ˆé˜Ÿåˆ—ä¸­ï¼Œåˆ™CPUä¸èƒ½ç«‹å³å‘é€ä½¿æ— æ•ˆæ¶ˆæ¯ï¼Œå®ƒå¿…é¡»ç­‰å¾…æ— æ•ˆé˜Ÿåˆ—ä¸­çš„æ¡ç›®è¢«å¤„ç†ã€‚

### C.4.3 Invalidate Queues and Memory Barriers

å†…å­˜å±éšœæŒ‡ä»¤èƒ½å¤Ÿä¸ä½¿æ— æ•ˆé˜Ÿåˆ—äº¤äº’ï¼Œè¿™æ ·ï¼Œå½“ä¸€ä¸ªç‰¹å®šçš„CPUæ‰§è¡Œä¸€ä¸ªå†…å­˜å±éšœæ—¶ï¼Œå®ƒæ ‡è®°æ— æ•ˆé˜Ÿåˆ—ä¸­çš„æ‰€æœ‰æ¡ç›®ï¼Œå¹¶å¼ºåˆ¶æ‰€æœ‰åç»­çš„`load`æ“ä½œè¿›è¡Œç­‰å¾…ï¼Œç›´åˆ°æ‰€æœ‰æ ‡è®°çš„æ¡ç›®éƒ½ä¿å­˜åˆ°CPUçš„ç¼“å­˜ä¸­ã€‚

## C.5 Read and Write Memory Barriers

Roughly speakingï¼Œä¸€ä¸ªâ€œè¯»å†…å­˜å±éšœâ€ä»…ä»…æ ‡è®°å®ƒçš„ä½¿æ— æ•ˆé˜Ÿåˆ—ï¼Œä¸€ä¸ªâ€œå†™å†…å­˜å±éšœâ€ä»…ä»…æ ‡è®°å®ƒçš„å­˜å‚¨ç¼“å†²åŒºï¼Œè€Œå®Œæ•´çš„å†…å­˜å±éšœåŒæ—¶æ ‡è®°æ— æ•ˆé˜Ÿåˆ—åŠå­˜å‚¨ç¼“å†²åŒºã€‚

## C.6 Example Memory-Barrier Sequences
æœ¬èŠ‚æä¾›äº†ä¸€äº›æœ‰è¶£çš„ã€ä½†æ˜¯ç¨å¾®æœ‰ç‚¹ä¸ä¸€æ ·çš„å†…å­˜å±éšœç”¨æ³•ã€‚  
è™½ç„¶å®ƒä»¬èƒ½åœ¨å¤§å¤šæ•°æ—¶å€™æ­£å¸¸å·¥ä½œï¼Œä½†æ˜¯å…¶ä¸­ä¸€äº›åªèƒ½åœ¨ç‰¹å®šCPUä¸Šè¿è¡Œã€‚  
å¦‚æœç›®çš„æ˜¯ä¸ºäº†äº§ç”Ÿé‚£äº›èƒ½åœ¨æ‰€æœ‰CPUä¸Šéƒ½èƒ½è¿è¡Œçš„ä»£ç ï¼Œé‚£ä¹ˆè¿™äº›ç”¨æ³•å¿…é¡»è¦é¿å…ã€‚  
ä¸ºäº†æ›´å¥½ç†è§£å®ƒä»¬ä¹‹é—´çš„å¾®å¦™å·®åˆ«ï¼Œæˆ‘ä»¬é¦–å…ˆéœ€è¦å…³æ³¨ä¹±åºä½“ç³»ç»“æ„ã€‚  

### C.6.1 Ordering-Hostile Architecture
è¿™é‡Œä½œè€…è®¾è®¡äº†ä¸€ä¸ªè™šæ„çš„ã€æœ€å¤§é™åº¦çš„ä¹±åºä½“ç³»ç»“æ„ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š

![MfXWo4.png](https://s2.ax1x.com/2019/11/20/MfXWo4.png)

å…¶ç¡¬ä»¶çº¦æŸå¦‚ä¸‹ï¼š

1ï¼å•ä¸ª CPUæ€»æ˜¯æŒ‰ç…§ç¼–ç¨‹é¡ºåºæ¥æ„ŸçŸ¥å®ƒè‡ªå·±çš„å†…å­˜è®¿é—®ã€‚

2ï¼ä»…ä»…åœ¨æ“ä½œä¸åŒåœ°å€æ—¶ï¼ŒCPUæ‰å¯¹ç»™å®šçš„`store`æ“ä½œè¿›è¡Œé‡æ–°æ’åºã€‚

3ï¼ä¸€ä¸ªç‰¹å®š CPUï¼Œåœ¨å†…å­˜å±éšœä¹‹å‰çš„æ‰€æœ‰`load`æ“ä½œï¼ˆsmp_rmb()ï¼‰å°†åœ¨æ‰€æœ‰è¯»å†…å­˜å±éšœåé¢çš„æ“ä½œä¹‹å‰è¢«æ‰€æœ‰å…¶ä»–CPUæ‰€æ„ŸçŸ¥ã€‚

4ï¼ä¸€ä¸ªç‰¹å®š CPUï¼Œæ‰€æœ‰åœ¨å†™å†…å­˜å±éšœä¹‹å‰çš„å†™æ“ä½œï¼ˆsmp_wmb()ï¼‰éƒ½å°†åœ¨æ‰€æœ‰å†…å­˜å±éšœä¹‹åçš„å†™æ“ä½œä¹‹å‰ï¼Œè¢«æ‰€æœ‰å…¶ä»–CPUæ‰€æ„ŸçŸ¥ã€‚

5ï¼ä¸€ä¸ªç‰¹å®š CPUï¼Œæ‰€æœ‰åœ¨å†…å­˜å±éšœä¹‹å‰çš„å†…å­˜è®¿é—®ï¼ˆ`load`å’Œ`store`ï¼‰ï¼ˆsmp_mb()ï¼‰éƒ½å°†åœ¨æ‰€æœ‰å†…å­˜å±éšœä¹‹åçš„å†…å­˜è®¿é—®ä¹‹å‰ï¼Œè¢«æ‰€æœ‰å…¶ä»–CPUæ‰€æ„ŸçŸ¥ã€‚

> å°é—®é¢˜C.11ï¼šé’ˆå¯¹ä¸Šè¿°ç¬¬1ç‚¹â€”â€”æ¯ä¸ªCPUæŒ‰åºçœ‹åˆ°å®ƒè‡ªå·±çš„å†…å­˜è®¿é—®ï¼Œè¿™æ ·èƒ½å¤Ÿç¡®ä¿æ¯ä¸€ä¸ªç”¨æˆ·çº¿ç¨‹æŒ‰åºçœ‹åˆ°å®ƒè‡ªå·±å¯¹å†…å­˜çš„è®¿é—®å—ï¼Ÿä¸ºä»€ä¹ˆèƒ½ï¼Œä¸ºä»€ä¹ˆä¸èƒ½ï¼Ÿ

ç­”æ¡ˆï¼šä¸èƒ½ã€‚è€ƒè™‘è¿™æ ·ä¸€ç§æƒ…å†µï¼Œä¸€ä¸ªçº¿ç¨‹ä»ä¸€ä¸ªCPUè¿ç§»åˆ°å¦å¤–ä¸€ä¸ªCPUï¼Œç›®æ ‡CPUæ„ŸçŸ¥åˆ°æºCPUæœ€è¿‘å¯¹å†…å­˜çš„è®¿é—®æ˜¯ä¹±åºçš„ã€‚ä¸ºäº†ä¿è¯ç”¨æˆ·æ€çš„å®‰å…¨ï¼Œå†…æ ¸é»‘å®¢å¿…é¡»åœ¨è¿›ç¨‹åˆ‡æ¢æ—¶ä½¿ç”¨å†…å­˜å±éšœã€‚ä½†æ˜¯ï¼Œåœ¨è¿›ç¨‹åˆ‡æ¢æ—¶è¦æ±‚ä½¿ç”¨çš„é”æ“ä½œï¼Œå·²ç»è‡ªåŠ¨æä¾›äº†å¿…è¦çš„å†…å­˜å±éšœï¼Œè¿™å¯¼è‡´ç”¨æˆ·æ€ä»»åŠ¡å°†æŒ‰åºçœ‹åˆ°è‡ªå·±å¯¹å†…å­˜çš„è®¿é—®ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœä½ æ­£åœ¨è®¾è®¡ä¸€ä¸ª`super-optimized scheduler`ï¼Œä¸ç®¡æ˜¯åœ¨å†…æ ¸æ€è¿˜æ˜¯ç”¨æˆ·æ€ï¼Œéƒ½è¦æ³¨æ„è¿™ç§æƒ…å½¢ã€‚

### C.6.2 Example 1
åˆå§‹çŠ¶æ€ï¼š`a == b == c == 0`

![MfXWo4.png](https://s2.ax1x.com/2019/11/20/MfXWo4.png)

![Mfz4HK.png](https://s2.ax1x.com/2019/11/20/Mfz4HK.png)


æˆ‘ä»¬å‡è®¾CPU 0æœ€è¿‘ç»å†äº†å¤ªå¤šcache missï¼Œä»¥è‡³äºå®ƒçš„message queueæ»¡äº†ã€‚CPU 1æ¯”è¾ƒå¹¸è¿ï¼Œå®ƒæ“ä½œçš„å†…å­˜å˜é‡åœ¨cachelineä¸­éƒ½æ˜¯exclusiveçŠ¶æ€ï¼Œä¸éœ€è¦å‘é€å’Œnode 1è¿›è¡Œäº¤äº’çš„messageï¼Œå› æ­¤å®ƒçš„message queueæ˜¯ç©ºçš„ã€‚å¯¹äºCPU0è€Œè¨€ï¼Œaå’Œbçš„èµ‹å€¼éƒ½å¾ˆå¿«ä½“ç°åœ¨äº†NODE 0çš„cacheä¸­ï¼ˆCPU1ä¹Ÿæ˜¯å¯è§çš„ï¼‰ï¼Œä¸è¿‡node 1ä¸çŸ¥é“ï¼Œå› ä¸ºmessageéƒ½é˜»å¡åœ¨äº†cpu 0çš„message queueä¸­ã€‚ä¸ä¹‹ç›¸åçš„æ˜¯CPU1ï¼Œå…¶å¯¹cçš„èµ‹å€¼å¯ä»¥é€šè¿‡message queueé€šçŸ¥åˆ°node1ã€‚è¿™æ ·å¯¼è‡´çš„æ•ˆæœå°±æ˜¯ï¼Œä»cpu2çš„è§’åº¦çœ‹ï¼Œå®ƒå…ˆè§‚å¯Ÿåˆ°äº†CPU1ä¸Šçš„c=1èµ‹å€¼ï¼Œç„¶åæ‰çœ‹åˆ°CPU0ä¸Šçš„å¯¹aå˜é‡çš„èµ‹å€¼ï¼Œè¿™ä¹Ÿå¯¼è‡´äº†å°½ç®¡ä½¿ç”¨äº†memory barrierï¼ŒCPU2ä¸Šä»ç„¶é­é‡äº†assert failã€‚ä¹‹æ‰€ä»¥ä¼šfailï¼Œä¸»è¦æ˜¯åœ¨cpu2ä¸Šå‘ç”Ÿäº†å½“zç­‰äº1çš„æ—¶å€™ï¼Œå´å‘ç°xç­‰äº0ã€‚

> æˆ‘çš„å°é—®é¢˜ï¼šè¿™é‡Œçš„`Message Queue`æŒ‡çš„æ˜¯ä»€ä¹ˆï¼Ÿ

æˆ‘çš„ç­”æ¡ˆï¼šä¸æ˜¯`store buffer`ä¹Ÿä¸æ˜¯`invalid queue`ï¼Œå› ä¸ºå¦‚æ–‡ä¸­æ‰€è¿°ï¼š_aå’Œbçš„èµ‹å€¼éƒ½å¾ˆå¿«ä½“ç°åœ¨äº†NODE 0çš„cacheä¸­ï¼ˆCPU1ä¹Ÿæ˜¯å¯è§çš„ï¼‰_ï¼Œè¯´æ˜æ­¤æ—¶æ–°å€¼å·²ç»ä»`store buffer`ä¸­å†™åˆ°äº†`cache`ä¸­ï¼Œä½†æ˜¯`Invalidate`æ¶ˆæ¯è¿˜æ²¡å‘å‡ºå»ã€‚  
æ‰€ä»¥è¯´æ˜è¿™é‡Œçš„`message queue`å°±æ˜¯å­˜æ”¾çš„å°±æ˜¯æœ¬CPUè¦å‘é€çš„`message`ï¼Œå¯èƒ½å †ç§¯çš„æ˜¯é‚£äº›å·²ç»å‘å‡ºå»ä½†æ˜¯è¿˜æ²¡å¾—åˆ°åº”ç­”çš„`message`ã€‚

> å°é—®é¢˜C.12ï¼šè¿™æ®µä»£ç å¯ä»¥é€šè¿‡åœ¨CPU1çš„â€œwhileâ€å’Œå¯¹â€œcâ€çš„èµ‹å€¼ä¹‹é—´æ’å…¥ä¸€ä¸ªå†…å­˜å±éšœæ¥ä¿®å¤å—ï¼Ÿ(è§`C.6.3 Example 2`)ä¸ºä»€ä¹ˆèƒ½ï¼Œä¸ºä»€ä¹ˆä¸èƒ½ï¼Ÿ 

ç­”æ¡ˆï¼šä¸èƒ½ï¼Œè¿™æ ·çš„å†…å­˜å±éšœä»…ä»…å¼ºåˆ¶CPU1æœ¬åœ°çš„å†…å­˜é¡ºåºã€‚å®ƒå¯¹CPU0å’ŒCPU1ä¹‹é—´çš„å…³è”é¡ºåºæ²¡æœ‰æ•ˆæœï¼Œå› æ­¤æ–­è¨€ä»ç„¶ä¼šå¤±è´¥ã€‚

**ä¿è¯(Guarantee)**:ä½†æ˜¯æ‰€æœ‰ä¸»æµè®¡ç®—æœºç³»ç»Ÿæä¾›ä¸€ç§â€œå¯ä¼ é€’â€æœºåˆ¶ï¼Œè¿™å°†æä¾›ä¸€ç§ç›´è§‚æ„Ÿè§‰ä¸Šçš„é¡ºåºï¼Œå¦‚æœBçœ‹è§Açš„æ“ä½œï¼Œå¹¶ä¸”Cçœ‹è§Bçš„æ“ä½œï¼Œé‚£ä¹ˆCå¿…å®šä¹Ÿçœ‹è§Açš„æ“ä½œã€‚

### C.6.3 Example 2

![MfzoND.png](https://s2.ax1x.com/2019/11/20/MfzoND.png)

åˆ†æè§ä¸Šè¿°å°é—®é¢˜`C.12`ã€‚

ä»åŸç†ä¸Šæ¥è¯´ï¼Œç¼–å†™å¯ç§»æ¤ä»£ç ä¸èƒ½ç”¨ä¸Šé¢çš„ä¾‹å­ï¼Œä½†æ˜¯ï¼Œæ­£å¦‚å‰é¢ä¸€æ ·ï¼Œå®é™…ä¸Šè¿™æ®µä»£ç å¯ä»¥åœ¨å¤§å¤šæ•°ä¸»æµçš„è®¡ç®—æœºæ­£å¸¸è¿è¡Œã€‚

### C.6.4 Example 3

![MfzqgA.png](https://s2.ax1x.com/2019/11/20/MfzqgA.png)

è¯·æ³¨æ„ï¼Œä¸ç®¡æ˜¯CPU 1 è¿˜æ˜¯ CPU 2éƒ½è¦çœ‹åˆ°CPU0åœ¨ç¬¬ä¸‰è¡Œå¯¹â€œbâ€çš„èµ‹å€¼åï¼Œæ‰èƒ½å¤„ç†ç¬¬5è¡Œã€‚ä¸€æ—¦CPU 1å’Œ2å·²ç»æ‰§è¡Œäº†ç¬¬4è¡Œçš„å†…å­˜å±éšœï¼Œå®ƒä»¬å°±èƒ½å¤Ÿçœ‹åˆ°CPU0åœ¨ç¬¬2è¡Œçš„å†…å­˜å±éšœå‰çš„æ‰€æœ‰èµ‹å€¼ã€‚ç±»ä¼¼çš„ï¼ŒCPU0åœ¨ç¬¬8è¡Œçš„å†…å­˜å±éšœä¸CPU1å’ŒCPU2åœ¨ç¬¬4è¡Œçš„å†…å­˜å±éšœæ˜¯ä¸€å¯¹å†…å­˜å±éšœï¼Œå› æ­¤CPU0å°†ä¸ä¼šæ‰§è¡Œç¬¬9è¡Œçš„å†…å­˜èµ‹å€¼ï¼Œç›´åˆ°å®ƒå¯¹â€œaâ€çš„èµ‹å€¼è¢«å…¶ä»–CPUå¯è§ã€‚å› æ­¤ï¼ŒCPU2åœ¨ç¬¬9è¡Œçš„assertå°†ä¸ä¼šè§¦å‘ã€‚

Linuxå†…æ ¸çš„synchronize_rcuï¼ˆï¼‰åŸè¯­ä½¿ç”¨äº†ç±»ä¼¼äºæœ¬ä¾‹ä¸­çš„ç®—æ³•ã€‚

> å°é—®é¢˜C.14ï¼šå¦‚æœåœ¨è¡¨C.4çš„ä¾‹å­ä¸­ï¼ŒCPU 2 æ‰§è¡Œä¸€ä¸ªæ–­è¨€assertï¼ˆeï¼ï¼0||cï¼ï¼1ï¼‰ï¼Œè¿™ä¸ªæ–­è¨€ä¼šè¢«è§¦å‘å—ï¼Ÿ

ç­”æ¡ˆï¼šç»“æœä¾èµ–äºCPUæ˜¯å¦æ”¯æŒâ€œå¯ä¼ é€’æ€§â€ã€‚æ¢å¥è¯è¯´ï¼Œé€šè¿‡åœ¨CPU 0å¯¹â€œcâ€çš„åŠ è½½å’Œå¯¹â€œeâ€çš„å­˜å‚¨ä¹‹é—´çš„å†…å­˜å±éšœï¼ŒCPU 0åœ¨çœ‹åˆ°CPU 1å¯¹â€œcâ€çš„å­˜å‚¨ä¹‹åï¼Œæ‰å¯¹â€œeâ€è¿›è¡Œå­˜å‚¨ã€‚å¦‚æœå…¶ä»–CPUçœ‹åˆ°CPU 0å¯¹â€œeâ€çš„å­˜å‚¨ï¼Œé‚£ä¹ˆæ˜¯å¦èƒ½å¤Ÿä¿è¯çœ‹åˆ°CPU 1çš„å­˜å‚¨ï¼Ÿ

**ä¿è¯(Guarantee)**:æ‰€æœ‰æˆ‘å…³æ³¨åˆ°çš„CPUéƒ½å£°ç§°æä¾›å¯ä¼ é€’æ€§ã€‚

## C.7 Memory-Barrier Instructions For Specific CPUs

#### å†…å­˜åºæ¨¡å‹
æ¯ä¸ªCPUéƒ½æœ‰å®ƒè‡ªå·±ç‰¹å®šçš„å†…å­˜å±éšœæŒ‡ä»¤ï¼Œè¿™å¯èƒ½ä¼šç»™æˆ‘ä»¬å¸¦æ¥ä¸€äº›ç§»æ¤æ€§æ–¹é¢çš„æŒ‘æˆ˜ï¼Œå¦‚è¡¨C.5æ‰€ç¤ºã€‚

![MhPjk6.png](https://s2.ax1x.com/2019/11/20/MhPjk6.png)

å®é™…ä¸Šï¼Œå¾ˆå¤šè½¯ä»¶ç¯å¢ƒï¼ŒåŒ…æ‹¬pthreadså’ŒJavaï¼Œç®€å•çš„ç¦æ­¢ç›´æ¥ä½¿ç”¨å†…å­˜å±éšœï¼Œå¼ºåˆ¶è¦æ±‚ç¨‹åºå‘˜ä½¿ç”¨äº’æ–¥åŸè¯­ï¼Œè¿™äº›äº’æ–¥åŸè¯­åŒ…å«å†…å­˜å±éšœï¼Œå¯¹å†…å­˜å±éšœè¿›è¡Œæ‰€éœ€çš„æ‰©å±•ã€‚

åœ¨è¡¨C.5ä¸­ï¼Œå‰`4`åˆ—è¡¨ç¤ºCPUæ˜¯å¦å…è®¸4ç§åŠ è½½å’Œå­˜å‚¨ç»„åˆè¿›è¡Œé‡æ’ã€‚

ç¬¬`5-6`åˆ—è¡¨ç¤ºCPUæ˜¯å¦å…è®¸åŠ è½½/å­˜å‚¨æ“ä½œä¸åŸå­æŒ‡ä»¤ä¸€èµ·è¿›è¡Œé‡æ’ã€‚

ç¬¬`7`åˆ—ï¼Œæ•°æ®ä¾èµ–è¯»é‡æ’ï¼Œéœ€è¦ç”±éšåä¸Alpha CPUç›¸å…³çš„ç« èŠ‚è¿›è¡Œè§£é‡Šã€‚ç®€çŸ­çš„è®²ï¼ŒAlphaéœ€è¦ä¸ºå…³è”æ•°æ®ä¹‹é—´çš„è¯»ä»¥åŠæ›´æ–°ä½¿ç”¨å†…å­˜å±éšœã€‚æ˜¯çš„ï¼Œè¿™è¡¨ç¤ºAlphaç¡®å®å¯èƒ½åœ¨å®ƒå–å¾—æŒ‡é’ˆæœ¬èº«çš„å€¼ä¹‹å‰ï¼Œå–å¾—æŒ‡é’ˆæŒ‡å‘çš„å€¼ã€‚è¿™å¬èµ·æ¥å¾ˆå¥‡æ€ªï¼Œä½†æ˜¯ç¡®å®æ˜¯çœŸçš„ã€‚  

è¿™ç§æç«¯å¼±å†…å­˜åºæ¨¡å‹çš„å¥½å¤„æ˜¯ï¼ŒAlphaå¯ä»¥ä½¿ç”¨æ›´ç®€å•çš„ç¼“å­˜ç¡¬ä»¶ï¼Œå› è€Œå…è®¸æ›´é«˜çš„æ—¶é’Ÿé¢‘ç‡ã€‚

ç¬¬`8`åˆ—è¡¨ç¤ºç‰¹å®šCPUæ˜¯å¦æ‹¥æœ‰ä¸€ä¸ªä¸ä¸€è‡´çš„æŒ‡ä»¤ç¼“å­˜å’Œæµæ°´çº¿ã€‚å¯¹äºè‡ªä¿®æ”¹ä»£ç æ¥è¯´ï¼Œä¸€äº›CPUéœ€è¦æ‰§è¡Œç‰¹æ®Šçš„æŒ‡ä»¤ã€‚

å¸¦æ‹¬å·çš„CPUåç§°è¡¨ç¤ºCPUå…è®¸è¿™æ ·çš„æ¨¡å¼ï¼Œä½†æ˜¯å®é™…ä¸Šå¾ˆå°‘è¢«ä½¿ç”¨ã€‚

> åœ¨2018ç‰ˆçš„perbookä¸­çš„`15.4`èŠ‚æä¾›äº†æœ€æ–°çš„å†…å­˜åºå›¾ã€‚  
![MhiBH1.png](https://s2.ax1x.com/2019/11/20/MhiBH1.png)

#### å†…æ ¸ä¸­çš„å†…å­˜å±éšœæŒ‡ä»¤

1ï¼smp_mbï¼ˆï¼‰ï¼šåŒæ—¶é’ˆå¯¹åŠ è½½ã€å­˜å‚¨è¿›è¡Œæ’åºçš„å†…å­˜å±éšœã€‚è¿™è¡¨ç¤ºåœ¨å†…å­˜å±éšœä¹‹å‰çš„åŠ è½½ã€å­˜å‚¨ï¼Œéƒ½å°†åœ¨å†…å­˜å±éšœä¹‹åçš„åŠ è½½ã€å­˜å‚¨ä¹‹å‰è¢«æäº¤åˆ°å†…å­˜ã€‚

2ï¼smp_rmbï¼ˆï¼‰ï¼šä»…ä»…å¯¹åŠ è½½è¿›è¡Œæ’åºçš„è¯»å†…å­˜å±éšœã€‚

3ï¼smp_wmbï¼ˆï¼‰ï¼šä»…ä»…å¯¹å­˜å‚¨è¿›è¡Œæ’åºçš„å†™å†…å­˜å±éšœã€‚

4ï¼smp_read_barrier_dependsï¼ˆï¼‰ï¼šå¼ºåˆ¶å°†ä¾èµ–äºä¹‹å‰æ“ä½œçš„åç»­æ“ä½œè¿›è¡Œæ’åºã€‚é™¤äº†ALPHAä¹‹å¤–ï¼Œè¿™ä¸ªåŸè¯­åœ¨å…¶ä»–ä½“ç³»ä¸Šéƒ½æ˜¯ç©ºæ“ä½œã€‚

5ï¼mmiowbï¼ˆï¼‰ï¼šå¼ºåˆ¶å°†é‚£äº›ç”±å…¨å±€è‡ªæ—‹é”ä¿æŠ¤çš„MMIOå†™æ“ä½œè¿›è¡Œæ’åºã€‚åœ¨è‡ªæ—‹é”å·²ç»å¼ºåˆ¶ç¦æ­¢MMIOä¹±åºçš„å¹³å°ä¸­ï¼Œè¿™ä¸ªåŸè¯­æ˜¯ç©ºæ“ä½œã€‚mmiowbï¼ˆï¼‰éç©ºçš„å¹³å°åŒ…æ‹¬ä¸€äº›ï¼ˆä½†æ˜¯ä¸æ˜¯å…¨éƒ¨ï¼‰IA64ã€FRVã€MIPSå’ŒSHã€‚è¿™ä¸ªåŸè¯­æ¯”è¾ƒæ–°ï¼Œå› æ­¤å¾ˆå°‘æœ‰é©±åŠ¨ä½¿ç”¨åˆ°äº†å®ƒã€‚
> æˆ‘çš„å°é—®é¢˜ï¼šä»€ä¹ˆæ˜¯`MMIO`ï¼Ÿå…¨ä¹¦å¤šæ¬¡æåˆ°è¿™ä¸ªæ¦‚å¿µï¼ŒæŠŠå®ƒå½“æˆä¸€ç§éé€šç”¨åœºæ™¯ä½œä¸ºè€ƒè™‘ã€‚

`smp_`å‰ç¼€ä»£è¡¨è¿™äº›åŸè¯­ä»…ä»…åœ¨SMPå†…æ ¸ä¸Šæ‰äº§ç”Ÿä»£ç ï¼Œå®ƒä»¬éƒ½å­˜åœ¨ä¸€ä¸ª`UP`ç‰ˆæœ¬ï¼ˆåˆ†åˆ«æ˜¯mb()ã€rmb()ã€wmb()å’Œread_barrier_depends()ï¼‰ï¼Œå³ä½¿åœ¨`UP`å†…æ ¸ä¸­ï¼Œè¿™äº›åŸè¯­åœ¨ä¹Ÿç”Ÿæˆä»£ç ã€‚
> æˆ‘çš„å°é—®é¢˜ï¼šä»€ä¹ˆæ˜¯`SMP`å†…æ ¸ï¼Œä»€ä¹ˆæ˜¯`UP`å†…æ ¸ã€‚


### C.7.3 ARMv7-A/R
ARM CPUæ—åœ¨åµŒå…¥å¼åº”ç”¨ä¸­æä¸ºæµè¡Œï¼Œç‰¹åˆ«æ˜¯åœ¨ç”µæºå—é™çš„åº”ç”¨ä¸­ï¼Œå¦‚ç§»åŠ¨ç”µè¯ã€‚è™½ç„¶å¦‚æ­¤ï¼ŒARMå¤šæ ¸å·²ç»å­˜åœ¨äº”å¹´ä»¥ä¸Šçš„æ—¶é—´äº†ã€‚å®ƒçš„å†…å­˜æ¨¡å‹ç±»ä¼¼äºPowerï¼ˆå‚è§C.7.6èŠ‚ï¼‰ï¼Œä½†æ˜¯ARMä½¿ç”¨äº†ä¸åŒçš„å†…å­˜å±éšœæŒ‡ä»¤é›†ï¼š

1ï¼DMBï¼ˆæ•°æ®å†…å­˜å±éšœï¼‰å¯¼è‡´åœ¨å±éšœå‰çš„ç›¸åŒç±»å‹çš„æ“ä½œï¼Œçœ‹èµ·æ¥å…ˆäºå±éšœåçš„æ“ä½œå…ˆæ‰§è¡Œã€‚æ“ä½œç±»å‹å¯ä»¥æ˜¯æ‰€æœ‰æ“ä½œï¼Œä¹Ÿå¯èƒ½ä»…é™äºå†™æ“ä½œã€‚

> ARM allows cache coherence to have one of three scopes: single processor, a subset of the processors (â€œinnerâ€) and global (â€œouterâ€).

ARM å…è®¸ä¸‰ç§èŒƒå›´çš„ç¼“å­˜ä¸€è‡´æ€§ï¼šå•å¤„ç†å™¨ï¼Œå¤„ç†å™¨å­é›†ï¼ˆâ€œinnerâ€ï¼‰ä»¥åŠå…¨å±€èŒƒå›´å†…çš„ä¸€è‡´ï¼ˆâ€œouterâ€ï¼‰ã€‚

2ï¼DSBï¼ˆæ•°æ®åŒæ­¥å±éšœï¼‰å¯¼è‡´ç‰¹å®šç±»å‹çš„æ“ä½œï¼Œåœ¨éšåçš„ä»»ä½•æ“ä½œè¢«æ‰§è¡Œå‰ï¼ŒçœŸçš„å·²ç»å®Œæˆã€‚æ“ä½œç±»å‹ä¸DMBç›¸åŒã€‚åœ¨ARMä½“ç³»æ—©æœŸçš„ç‰ˆæœ¬ä¸­ï¼ŒDSBæŒ‡ä»¤è¢«ç§°ä¸ºDWBï¼ˆæ¸…é™¤å†™ç¼“å†²åŒºè¿˜æ˜¯æ•°æ®å†™å±éšœçš†å¯ï¼‰ã€‚

3ï¼ISBï¼ˆæŒ‡ä»¤åŒæ­¥å±éšœï¼‰åˆ·æ–°CPUæµæ°´çº¿ï¼Œè¿™æ ·æ‰€æœ‰éšåçš„æŒ‡ä»¤ä»…ä»…åœ¨ISBæŒ‡ä»¤å®Œæˆåæ‰è¢«è¯»å–ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä½ ç¼–å†™ä¸€ä¸ªè‡ªä¿®æ”¹çš„ç¨‹åºï¼ˆå¦‚JITï¼‰ï¼Œåº”å½“åœ¨ç”Ÿæˆä»£ç åŠæ‰§è¡Œä»£ç ä¹‹é—´æ‰§è¡Œä¸€ä¸ªISBæŒ‡ä»¤ã€‚

æ²¡æœ‰å“ªä¸€ä¸ªæŒ‡ä»¤ä¸Linuxçš„rmbï¼ˆï¼‰è¯­ä¹‰å®Œå…¨ç›¸ç¬¦ã€‚å› æ­¤å¿…é¡»å°†rmbï¼ˆï¼‰å®ç°ä¸ºä¸€ä¸ªå®Œæ•´çš„DMBã€‚DMBå’ŒDSBæŒ‡ä»¤å…·æœ‰è®¿é—®é¡ºåºæ–¹é¢çš„é€’å½’å®šä¹‰ï¼Œå…¶å…·æœ‰ç±»ä¼¼äºPOWERæ¶æ„ç´¯ç§¯æ€§çš„æ•ˆæœã€‚

> ARM also implements control dependencies, so that if a conditional branch depends on a load, then any store executed after that conditional branch will be ordered after the load. 

ARM ä¹Ÿå®ç°äº†æ§åˆ¶ä¾èµ–ï¼Œå› æ­¤ï¼Œå¦‚æœä¸€ä¸ªæ¡ä»¶åˆ†æ”¯ä¾èµ–äºä¸€ä¸ªåŠ è½½æ“ä½œï¼Œé‚£ä¹ˆåœ¨æ¡ä»¶åˆ†æ”¯åé¢çš„å­˜å‚¨æ“ä½œéƒ½åœ¨åŠ è½½æ“ä½œåæ‰§è¡Œã€‚

> However, loads following the conditional branch will not be guaranteed to be ordered unless there is an ISB instruction between the branch and the load. Consider the following example:

ä½†æ˜¯ï¼Œå¹¶ä¸ä¿è¯åœ¨æ¡ä»¶åˆ†æ”¯åé¢çš„åŠ è½½æ“ä½œä¹Ÿæ˜¯æœ‰åºçš„ï¼Œé™¤éåœ¨åˆ†æ”¯å’ŒåŠ è½½ä¹‹é—´æœ‰ä¸€ä¸ªISBæŒ‡ä»¤ã€‚å¦‚ä¸‹ä¾‹ï¼š

```c
r1 = x;
if (r1 == 0)
    nop();
y = 1;
r2 = z;
ISB();
r3 = z;
```

> In this example, `load-store control dependency ordering` causes the load from x on line 1 to be ordered before the store to y on line 4. 

åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œå­˜å‚¨/åŠ è½½æ§åˆ¶ä¾èµ–å¯¼è‡´åœ¨ç¬¬1è¡Œçš„åŠ è½½xæ“ä½œè¢«æ’åºåœ¨ç¬¬4è¡Œå¯¹Yçš„å­˜å‚¨æ“ä½œä¹‹å‰ã€‚

> However, ARM does not respect `load-load control dependencies`, so that the load on line 1 might well happen after the load on line 5. 

ä½†æ˜¯ï¼ŒARMå¹¶ä¸è€ƒè™‘åŠ è½½/åŠ è½½æ§åˆ¶ä¾èµ–ï¼Œå› æ­¤ï¼Œç¬¬1è¡Œçš„åŠ è½½ä¹Ÿè®¸ä¼šåœ¨ç¬¬5è¡Œçš„åŠ è½½æ“ä½œåé¢å‘ç”Ÿã€‚

> On the other hand, the combination of the conditional branch on line 2 and the ISB instruction on line 6 ensures that the load on line 7 happens after the load on line 1.

å¦ä¸€æ–¹é¢ï¼Œç¬¬2è¡Œçš„æ¡ä»¶åˆ†æ”¯ä¸ç¬¬6è¡Œçš„ISBæŒ‡ä»¤ç¡®ä¿ç¬¬7è¡Œåœ¨ç¬¬1è¡Œåé¢å‘ç”Ÿã€‚

>  Note that inserting an additional ISB instruction somewhere between lines 3 and 4 would enforce ordering between lines 1 and 5.

æ³¨æ„ï¼Œåœ¨ç¬¬3è¡Œå’Œç¬¬4è¡Œä¹‹é—´æ’å…¥ä¸€ä¸ªISBæŒ‡ä»¤å°†ç¡®ä¿ç¬¬1è¡Œå’Œç¬¬5è¡Œä¹‹é—´çš„é¡ºåºã€‚ å¦‚ä¸‹æ‰€ç¤ºï¼š

```c
r1 = x;
if (r1 == 0)
    nop();
ISB();
y = 1;
r2 = z;
ISB();
r3 = z;
```

### 15.4.3 ARMv8
> ARMv8â€™s memory model closely resembles its ARMv7 counterpart, but adds load-acquire (LDLARB, LDLARH, and LDLAR) and store-release (STLLRB, STLLRH, and STLLR) instructions. 

ARMv8çš„å†…å­˜æ¨¡å‹ä¸ARMv7çš„å­˜å‚¨å™¨æ¨¡å‹éå¸¸ç›¸ä¼¼ï¼Œä½†æ˜¯å¢åŠ äº†`load-acquire`ï¼ˆ`LDLARB`ï¼Œ`LDLARH`å’Œ`LDLAR`ï¼‰å’Œ`store-release`ï¼ˆ`STLLRB`ï¼Œ`STLLRH`å’Œ`STLLR`ï¼‰æŒ‡ä»¤ã€‚  

> These instructions act as â€œhalf memory barriersâ€, so that ARMv8 CPUs can reorder previous accesses with a later LDLAR instruction, but are prohibited from reordering an earlier LDLAR instruction with later accesses, as fancifully depicted in Figure 15.14.
![MIkC4I.png](https://s2.ax1x.com/2019/11/21/MIkC4I.png)
Similarly, ARMv8 CPUs can reorder an earlier STLLR instruction with a subsequent access, but are prohibited from reordering previous accesses with a later STLLR instruction.   
As one might expect, this means that these instructions directly support the C11 notion of load-acquire and store-release.(æ­¤æ¦‚å¿µçš„è¯´æ˜å¯å‚è€ƒ[æ­¤å¤„](https://juejin.im/post/5daaf3d4f265da5b950a6337))  

`Read-Acquire`ç”¨äºä¿®é¥°å†…å­˜è¯»å–æŒ‡ä»¤ï¼Œä¸€æ¡ `read-acquire` çš„è¯»æŒ‡ä»¤ä¼šç¦æ­¢å®ƒåé¢çš„å†…å­˜æ“ä½œæŒ‡ä»¤è¢«æå‰æ‰§è¡Œï¼Œå³åç»­å†…å­˜æ“ä½œæŒ‡ä»¤é‡æ’æ—¶æ— æ³•å‘ä¸Šè¶Šè¿‡å±éšœï¼Œä¸‹å›¾ç›´è§‚çš„æè¿°äº†è¿™ä¸€åŠŸèƒ½ï¼š  

![MInmQI.png](https://s2.ax1x.com/2019/11/21/MInmQI.png)  

`Write-Release`ç”¨äºä¿®é¥°å†…å­˜å†™æŒ‡ä»¤ï¼Œä¸€æ¡ `write-release` çš„å†™æŒ‡ä»¤ä¼šç¦æ­¢å®ƒä¸Šé¢çš„å†…å­˜æ“ä½œæŒ‡ä»¤è¢«æ»ååˆ°å†™æŒ‡ä»¤å®Œæˆåæ‰æ‰§è¡Œï¼Œå³å†™æŒ‡ä»¤ä¹‹å‰çš„å†…å­˜æ“ä½œæŒ‡ä»¤é‡æ’æ—¶ä¸ä¼šå‘ä¸‹è¶Šè¿‡å±éšœï¼Œä¸‹å›¾ç›´è§‚æè¿°äº†è¿™ä¸€åŠŸèƒ½ï¼š  

![MInnyt.png](https://s2.ax1x.com/2019/11/21/MInnyt.png)  

> However, ARMv8 goes well beyond the C11 memory model by mandating that the combination of a store-release and load-acquire act as a full barrier under many circumstances. 
For example, in ARMv8, given a store followed by a store-release followed a load-acquire followed by a load, all to different variables and all from a single CPU, all CPUs would agree that the initial store preceded the final load.   
Interestingly enough, most TSO architectures (including x86 and the mainframe) do not make this guarantee, as the two loads could be reordered before the two stores. 

é™¤äº†æ”¯æŒ`C11`æ ‡å‡†ä¸­å¯¹åº”çš„è¯­ä¹‰ä¹‹å¤–ï¼ŒARMv8åœ¨è®¸å¤šæƒ…å†µä¸‹å°†`store-release`å’Œ`load-acquire`çš„ç»“åˆä½œä¸º`full barrier`ã€‚
ä¾‹å¦‚ï¼Œåœ¨ARMv8ä¸­ï¼Œç»™å‡ºå¦‚ä¸‹æ“ä½œåºåˆ—ï¼Œæ‰€æœ‰è¿™äº›éƒ½å­˜å‚¨åœ¨ä¸åŒçš„å˜é‡ä¸­ï¼Œå¹¶ä¸”å…¨éƒ¨æ¥è‡ªä¸€ä¸ª`CPU`ï¼Œæ‰€æœ‰CPUéƒ½åŒæ„ç¬¬`1`è¡Œçš„`store`åœ¨ç¬¬`4`è¡Œçš„`load`ä¹‹å‰æ‰§è¡Œã€‚

```asm
store
store-release
load-acquire
load
```
æœ‰è¶£çš„æ˜¯ï¼Œå¤§å¤šæ•°`TSO(total store order)`ä½“ç³»ç»“æ„ï¼ˆåŒ…æ‹¬x86å’Œå¤§å‹æœºï¼‰éƒ½ä¸èƒ½ä¿è¯è¿™ä¸€ç‚¹ï¼Œå› ä¸ºå¯ä»¥ä¸¤ä¸ª`store`ä¹‹å‰å¯¹è¿™ä¸¤ä¸ª`load`è¿›è¡Œé‡æ–°æ’åºã€‚

> ARMv8 is one of only two architectures that needs the smp_mb__after_spinlock() primitive to be a full barrier, due to its relatively weak lock-acquisition implementation in the Linux kernel.

ARMv8æ˜¯ä»…æœ‰çš„ä¸¤ç§éœ€è¦smp_mb__after_spinlockï¼ˆï¼‰åŸè¯­æˆä¸ºå®Œæ•´éšœç¢çš„ä½“ç³»ç»“æ„ä¹‹ä¸€ï¼Œè¿™æ˜¯ç”±äºå…¶åœ¨Linuxå†…æ ¸ä¸­çš„é”è·å–å®ç°ç›¸å¯¹è¾ƒå¼±ã€‚

> ARMv8 also has the distinction of being the first CPU whose vendor publicly defined its memory ordering with an executable formal model [ARM17].

ARMv8è¿˜æœ‰ä¸€ä¸ªåŒºåˆ«ï¼Œå®ƒæ˜¯ç¬¬ä¸€ä¸ªä¾›åº”å•†ä½¿ç”¨å¯æ‰§è¡Œçš„æ­£å¼æ¨¡å‹å…¬å¼€å®šä¹‰å…¶å†…å­˜é¡ºåºçš„CPUï¼Œè¯¦è§armç™½çš®ä¹¦ã€‚

> æˆ‘çš„å°é—®é¢˜ï¼š`LDXR/STXR`å’Œ`LDAXR/STLXR`çš„åŒºåˆ«ï¼Ÿ

ç­”æ¡ˆï¼š`LDXR/STXR`å…·æœ‰`Exclusive`è¯­ä¹‰ï¼Œè€Œ`LDAXR/STLXR`é™¤æ­¤ä¹‹å¤–è¿˜å…·æœ‰`Acquire-Release`è¯­ä¹‰ï¼Œç”¨äºä¿è¯æ‰§è¡Œé¡ºåºã€‚

### C.7.8 x86
ç”±äºx86 CPUæä¾›â€œ`process ordering`â€ï¼Œå› æ­¤æ‰€æœ‰CPUéƒ½ä¼šä¸€è‡´æ€§çš„çœ‹åˆ°æŸä¸ªç‰¹å®šCPUå¯¹å†…å­˜çš„å†™æ“ä½œã€‚

è¿™æ ·smp_wmbï¼ˆï¼‰å®ç°ä¸ºä¸€ä¸ªç©ºæ“ä½œã€‚ä½†æ˜¯ï¼Œå®ƒéœ€è¦ä¸€ä¸ªå¦‚ä¸‹æ‰€ç¤ºçš„ç¼–è¯‘å±éšœæŒ‡ä»¤`barrier()`ï¼Œä»¥é¿å…ç¼–è¯‘å™¨è¿›è¡Œæ€§èƒ½ä¼˜åŒ–ï¼Œè¿™æ ·çš„æ€§èƒ½ä¼˜åŒ–å¯¼è‡´è¶Šè¿‡smp_wmbï¼ˆï¼‰å‰åçš„æŒ‡ä»¤çš„é‡æ’ã€‚
```
#define barrier() __asm__ __volatile__("": : :"memory")
```

ä»å…¶ä»–æ–¹é¢æ¥è¯´ï¼Œx86 CPUä¼ ç»Ÿä¸Šä¸ä¿è¯`load`çš„é¡ºåºï¼Œsmp_mbï¼ˆï¼‰å’Œsmp_rmbï¼ˆï¼‰è¢«æ‰©å±•ä¸º`lock;addl`ã€‚è¿™ä¸ªåŸå­æŒ‡ä»¤å®é™…ä¸Šæ˜¯ä¸€ä¸ªåŒæ—¶é’ˆå¯¹`load`å’Œ`store`çš„å±éšœã€‚

Intelä¹Ÿä¸ºx86å‘å¸ƒäº†ä¸€ä¸ªå†…å­˜æ¨¡å‹ç™½çš®ä¹¦ï¼š[IntelÂ® 64 Architecture Memory Ordering White Paper](http://www.cs.cmu.edu/~410-f10/doc/Intel_Reordering_318147.pdf)ã€‚

äº‹å®è¯æ˜ï¼ŒIntel å®é™…çš„CPUæ‰§è¡Œæ¯”å‰é¢çš„è§„èŒƒè¦æ±‚æ›´ä¸¥çš„å†…å­˜åºï¼Œå› æ­¤ï¼Œè¿™ä¸ªè§„èŒƒäº‹å®ä¸Šåªæ˜¯å¼ºåˆ¶è§„èŒƒæ—©æœŸçš„è¡Œä¸ºã€‚

>Even more recently, Intel published an updated memory model for x86 [Int11, Section 8.2], which mandates a total global order for stores, although individual CPUs are still permitted to see their own stores as having happened earlier than this total global order would indicate. This exception to the total ordering is needed to allow important hardware optimizations involving store buffers. 

æœ€è¿‘ä¸€æ®µæ—¶é—´ï¼ŒIntel å‘å¸ƒäº†ä¸€ä¸ªæ›´æ–°çš„å†…å­˜æ¨¡å‹ï¼Œè¯¦è§[Int11](https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.pdf)çš„`8.2`èŠ‚â€”â€”å®ƒè¦æ±‚å¯¹`store`æ¥è¯´å®ç°å…¨å±€åºã€‚è™½ç„¶å¯¹å•ä¸ªCPUæ¥è¯´ï¼Œ**ä»ç„¶å…è®¸å®ƒçœ‹åˆ°è‡ªå·±çš„å­˜å‚¨æ“ä½œ**ï¼Œè€Œè¿™äº›æ“ä½œæ—©äºå…¨å±€åºå‘ç”Ÿã€‚è¿™ä¸ªå…¨å±€åºçš„ä¾‹å¤–æƒ…å†µæ˜¯å¿…è¦çš„ï¼Œå› ä¸ºæ¯ä¸ªCPUéœ€è¦å…¶`store buffer`çš„ä¼˜åŒ–ã€‚

> In addition, memory ordering obeys causality, so that if CPU 0 sees a store by CPU 1,then CPU 0 is guaranteed to see all stores that CPU 1 saw prior to its store. Software may use atomic operations to override these hardware optimizations, which is one reason that atomic operations tend to be more expensive than their non-atomic counterparts. This total store order is not guaranteed on older processors.

å¦å¤–ï¼Œå†…å­˜åºéµä»â€œä¼ é€’æ€§â€ï¼Œå› æ­¤ï¼Œå¦‚æœCPU0çœ‹åˆ°CPU1å­˜å‚¨çš„å€¼ï¼Œé‚£ä¹ˆCPU0ä¹Ÿèƒ½çœ‹åˆ°ï¼Œåœ¨CPU 1çš„å­˜å‚¨æ“ä½œä¹‹å‰ï¼Œå®ƒæ‰€èƒ½çœ‹åˆ°çš„å€¼ã€‚è½¯ä»¶å¯ä»¥ä½¿ç”¨åŸå­æ“ä½œï¼Œæ¥ä½¿è¿™äº›ä¼˜åŒ–æ— æ•ˆï¼Œè¿™ä¹Ÿæ˜¯åŸå­æ“ä½œæ¯”éåŸå­æ“ä½œå¼€é”€æ›´å¤§çš„åŸå› ä¹‹ä¸€ã€‚å…¨å±€å­˜å‚¨åºåœ¨è€çš„å¤„ç†å™¨ä¸Šå¹¶ä¸èƒ½å¾—åˆ°ä¿è¯ã€‚

> It is also important to note that atomic instructions operating on a given memory location should all be of the same size [Int11, Section 8.1.2.2]. For example, if you write a program where one CPU atomically increments a byte while another CPU executes a 4-byte atomic increment on that same location, you are on your own. 

æœ‰ä¸€ä¸ªç‰¹åˆ«éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨ä¸€ä¸ªç‰¹å®šå†…å­˜ä½ç½®çš„åŸå­æŒ‡ä»¤æ“ä½œåº”å½“å¯¹é½ç›¸åŒå¤§å°çš„å†…å­˜([Int11](https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.pdf)çš„`8.1.2.2`)ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä½ ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œå®ƒåœ¨ä¸€ä¸ªCPUä¸Šå¯¹ä¸€ä¸ªå­—èŠ‚è¿›è¡ŒåŸå­é€’å¢ï¼Œè€Œå¦ä¸€ä¸ªCPUå¯¹åŒä¸€ä¸ªåœ°å€æ‰§è¡Œä¸€ä¸ª4å­—èŠ‚åŸå­é€’å¢ï¼Œå…¶åæœéœ€è¦ç”±ä½ è‡ªå·±è´Ÿè´£ã€‚

> However, note that some SSE instructions are weakly ordered (clflush and non-temporal move instructions [Int04a]). CPUs that have SSE can use mfence for smp_mb(), lfence for smp_rmb(), and sfence for smp_wmb().

ä½†æ˜¯ï¼Œè¯·æ³¨æ„æŸäº›SSE æŒ‡ä»¤æ˜¯å¼±åºçš„ï¼ˆclflushåŠnon-temporalæ¬ç§»æŒ‡ä»¤[Int04a]ï¼‰ã€‚æœ‰SSEæŒ‡ä»¤çš„CPUå¯ä»¥ç”¨mfenceå®ç°smp_mbï¼ˆï¼‰ï¼Œlfenceå®ç°smp_rmbï¼ˆï¼‰ï¼Œsfenceå®ç°smp_wmbï¼ˆï¼‰ã€‚

>A few versions of the x86 CPU have a mode bit that enables out-of-order stores, and for these CPUs, smp_wmb() must also be defined to be lock;addl. 

æŸäº›ç‰ˆæœ¬çš„x86 CPUæœ‰ä¸€ä¸ªæ¨¡å¼ä½ï¼Œå…è®¸åœ¨å­˜å‚¨ä¹‹é—´ä¹±åºï¼Œåœ¨è¿™äº›CPUä¸Šï¼Œsmp_wmbï¼ˆï¼‰å¿…é¡»è¢«å®šä¹‰ä¸ºlockï¼›addlã€‚

>Although newer x86 implementations accommodate self-modifying code without any special instructions, to be fully compatible with past and potential future x86 implementations, a given CPU must execute a jump instruction or a serializing instruction (e.g., cpuid) between modifying the code and executing it [Int11, Section 8.1.3]

è™½ç„¶è¾ƒæ–°çš„x86 å®ç°å¯ä»¥é€‚åº”è‡ªä¿®æ”¹ä»£ç è€Œä¸éœ€è¦ä»»ä½•ç‰¹æ®ŠæŒ‡ä»¤ï¼Œä½†æ˜¯ä¸ºäº†å…¼å®¹æ—§çš„åŠä»¥åçš„x86å®ç°ï¼Œä¸€ä¸ªç‰¹å®šCPUå¿…é¡»åœ¨ä¿®æ”¹ä»£ç åŠæ‰§è¡Œè¯¥ä»£ç ä¹‹é—´ï¼Œæ‰§è¡Œä¸€ä¸ªè·³è½¬æŒ‡ä»¤æˆ–è€…ä¸²è¡ŒåŒ–æŒ‡ä»¤ï¼ˆä¾‹å¦‚cpuidç­‰ï¼‰[Int11ï¼Œ8.1.3èŠ‚]ã€‚


## C.8 Are Memory Barriers Forever?
è®¨è®ºæœªæ¥çš„CPUè®¾è®¡æ˜¯å¦ä¼šåšå‡ºä¸€å®šçš„æ”¹å˜ä½¿å¾—å†…å­˜å±éšœæˆä¸ºå†å²ã€‚ 

## C.9 Advice to Hardware Designers
è¿‡å»çš„ç¡¬ä»¶è®¾è®¡ä¸­å¼•å…¥çš„é—®é¢˜ï¼š
1. I/O devices that ignore cache coherence.
2. External busses that fail to transmit cache-coherence data.
3. Device interrupts that ignore cache coherence.
4. Inter-processor interrupts (IPIs) that ignore cache coherence.
5. Context switches that get ahead of cache coherence.
6. Overly kind simulators and emulators.

# å…¶ä»–å‚è€ƒèµ„æ–™
[å¤šè¿›ç¨‹å’Œå¤šçº¿ç¨‹çš„åŒºåˆ«](https://blog.csdn.net/linraise/article/details/12979473)
