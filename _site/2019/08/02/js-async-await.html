<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=gb2312" />
    <meta http-equiv="Content-Language" content="zh-CN" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- 360 -->
    <meta name="360-site-verification" content="fa6ca3a9a0330e9cecabee0a9fe1d52a" />
    <!-- 搜狗 -->
    <meta name="sogou_site_verification" content="oatSp9uAV5" />
    <!--熊掌号 -->
    <meta name="baidu-site-verification" content="Wkb0Jzk8yx" />
    <!-- Google Search Console -->
    <meta name="google-site-verification" content="IJrXvaK-Luj-lCGP7tymcCbkcfMKi82Y8V21qN9ZT0s" />
    <title>
        
            async 与 await 的用法详解
        
    </title>
    <link rel="shortcut icon" type="image/x-icon" href="/assets/img/favicon.ico">
    
    <link rel="stylesheet" href="/assets/css/materialize.min.css">
    <link rel="stylesheet" href="/assets/css/icons.css">
    

    
        
        <link rel="stylesheet" href="/assets/css/page.css">
        
    
        
        <link rel="stylesheet" href="/assets/css/post.css">
        
    
        
        <link rel="stylesheet" href="/assets/css/syntax.css">
        
    
        
        <link rel="stylesheet" href="/assets/css/article-category.css">
        
    

    
    <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml">
    <link rel="sitemap" type="application/xml" title="Sitemap" href="/sitemap.xml">	
    <!-- Begin Jekyll SEO tag v2.7.1 -->
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="async 与 await 的用法详解" />
<meta property="og:locale" content="zh_CN" />
<meta name="description" content="关于异步函数中 async 与 await 的用法详解" />
<meta property="og:description" content="关于异步函数中 async 与 await 的用法详解" />
<link rel="canonical" href="http://localhost:4000/2019/08/02/js-async-await" />
<meta property="og:url" content="http://localhost:4000/2019/08/02/js-async-await" />
<meta property="og:site_name" content="苏梓鑫的博客" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-08-02T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="async 与 await 的用法详解" />
<script type="application/ld+json">
{"url":"http://localhost:4000/2019/08/02/js-async-await","headline":"async 与 await 的用法详解","dateModified":"2019-08-02T00:00:00+08:00","datePublished":"2019-08-02T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2019/08/02/js-async-await"},"description":"关于异步函数中 async 与 await 的用法详解","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body>
    <header>
        <nav class="top-nav">
            
            <div class="nav-wrapper">
                <div class="container">
                    
                    <a class="page-title" href="/">苏梓鑫的博客</a>
                    <p class="head-message">学习&nbsp;&nbsp;总结&nbsp;&nbsp;分享&nbsp;&nbsp;提升</p>
                </div>
            </div>
        </nav>

        <div class="container">
            <a href="#" data-target="slide-out" class="sidenav-trigger top-nav full hide-on-large-only">
                <i class="material-icons">menu</i>
            </a>
        </div>
        <ul id="slide-out" class="sidenav sidenav-fixed" style="background-color:#ddd">
            <li>
                <div class="userView">
                    <img class="user-bg" src="/assets/img/bg.png" />
                    <a class="user-avatar" href="https://github.com/suzixin" target="_blank">
                        <img class="circle z-depth-2" src="/assets/img/user.png" width="64" />
                    </a>
                    <div class="white-text user-info">
                        苏梓鑫 <i>(Knight Huang)</i><br>
                        adahsuzixin@gmail.com
                    </div>
                </div>
            </li>
            <li><a class="waves-effect" href="/"><i class="material-icons">home</i>Home - 主页</a></li>
            <li><a class="waves-effect" href="/projects"><i class="material-icons">description</i>Github - 项目</a></li>
            <li><a class="waves-effect" href="/categories"><i class="material-icons">sort</i>Categories - 目录</a></li>
            <li><a class="waves-effect" href="/tags"><i class="material-icons">label</i>Tags - 标签</a></li>
            <li><a class="waves-effect" href="/feed.xml" target="_blank"><i class="material-icons">rss_feed</i>RSS - 订阅</a></li>
            <li><a class="waves-effect" href="/about"><i class="material-icons">person</i>About - 关于我</a></li>
            <li><a class="waves-effect" href="/contact"><i class="material-icons">email</i>Contact - 联系我</a></li>
            <!-- 华为云广告 -->
            <li class="ad">
                <!-- <a href="https://mp.weixin.qq.com/s/ujUoHc3grjO8LD_Bg1fckA" target="_blank"> -->
                <!-- <a href="https://mp.weixin.qq.com/s/MTbMlhjAx8R4fc8Po90EXg" target="_blank">
                    <img src="/assets/img/ad-huaweiyun.png" alt="" width="100%" />
                </a>
                <i class="material-icons" onclick="javascript:this.parentNode.style.display='none';">close</i> -->
            </li>
        </ul>
    </header>
    <main>

<div class="container">
    <div id="page-info">
        <h1 class="page-title white-text">async 与 await 的用法详解</h1>
    </div>
    <div id="page-content" class="row">
        <div id="post-info">
    <ul class="collapsible hoverable" data-collapsible="accordion">
        <li>
            <div class="collapsible-header grey lighten-4">
                <span>
                    <i class="material-icons tooltipped" data-position="left" data-delay="30" data-tooltip="Date">date_range</i>
                    02/08/2019 00:00<br />
                    <div id="busuanzi_container_site_pv">点击量：<span style="display: inline;" id="busuanzi_value_page_pv"></span>次</div>
                    <i id="indicate" class="right material-icons tooltipped" data-position="left" data-delay="30"
                        data-tooltip="Show extra info">info</i>
                </span>
            </div>
            <div class="collapsible-body">
                <span>
                    <i class="material-icons tooltipped" data-position="left" data-delay="30" data-tooltip="Categories">sort</i>
                    
                    
                    
                    <a href="/categories#javascript_cap"
                        target="_blank">
                        <div class="chip">JavaScript</div>
                    </a>
                    
                </span>
                <span>
                    <i class="material-icons tooltipped" data-position="left" data-delay="30" data-tooltip="Tags">label</i>
                    
                    
                    
                    <a href="/tags#asnyc" target="_blank">
                        <div class="chip">asnyc</div>
                    </a>
                    
                    
                    
                    <a href="/tags#await" target="_blank">
                        <div class="chip">await</div>
                    </a>
                    
                    
                    
                    <a href="/tags#异步_cap" target="_blank">
                        <div class="chip">异步</div>
                    </a>
                    
                </span>
            </div>
        </li>
    </ul>
</div>
<div class="divider"></div>
<div id="post-content" class="row">
    <div class="col s12">
        <h1 id="async">async</h1>

<h2 id="概念">概念</h2>

<p>用于声明异步函数，返回值为一个 <code class="language-plaintext highlighter-rouge">Promise</code> 对象，它以类似 <strong>同步</strong> 的方式来写异步方法，语法与声明函数类似，例如：</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nx">fn</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello world!</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">fn</span><span class="p">().</span><span class="kd">constructor</span><span class="p">);</span> <span class="c1">// Promise()</span>
<span class="c1">// 这里证明其返回值为一个 Promise 对象；</span>
</code></pre></div></div>

<h2 id="返回值">返回值</h2>

<p>也许这里会有疑问，返回值是 Promise 对象，那么函数本身定义的返回值跑到哪里去了呢？其实，熟悉 Promise 的就知道其异步结果是通过 <code class="language-plaintext highlighter-rouge">.then()</code> 或者 <code class="language-plaintext highlighter-rouge">.catch()</code> 方法来获取并进行进一步处理的，这样一个道理，定义的异步函数中的返回值会当成 <code class="language-plaintext highlighter-rouge">resolve</code> 状态来处理，一般用 <code class="language-plaintext highlighter-rouge">.then()</code> 方法处理，而如果定义的异步函数抛出错误，例如变量未定义，则会被当做 <code class="language-plaintext highlighter-rouge">reject</code> 状态来处理，一般使用 <code class="language-plaintext highlighter-rouge">.catch()</code> 方法来处理；</p>

<p>举例：</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 使用 .then() 的情况</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nx">fn1</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="dl">'</span><span class="s1">Hello world!</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">fn1</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>
<span class="p">});</span>
<span class="c1">// Hello world!</span>

<span class="c1">// 使用 .catch() 的情况</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nx">fn2</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">aaa</span><span class="p">);</span> <span class="c1">// 这里的变量 aaa 未定义，为了制造错误</span>
<span class="p">}</span>

<span class="nx">fn2</span><span class="p">().</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
<span class="p">});</span>
<span class="c1">// ReferenceError: aaa is not defined</span>
</code></pre></div></div>

<p>假如是既有返回值，又有错误的话，来看看结果如何：</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nx">fn3</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">aaa</span><span class="p">);</span> <span class="c1">// aaa 依然未定义；</span>
    <span class="k">return</span> <span class="dl">'</span><span class="s1">Hello world!</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">fn3</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">res</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>
<span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
<span class="p">});</span>
<span class="c1">// ReferenceError: aaa is not defined</span>
</code></pre></div></div>

<p>结果证明只会执行 <code class="language-plaintext highlighter-rouge">reject</code> 状态的情况下的语句，忽略了 <code class="language-plaintext highlighter-rouge">resolve</code> 时的代码，所以此处值得 <strong>注意</strong>；</p>

<h1 id="await">await</h1>

<h2 id="概念-1">概念</h2>

<p>用法顾名思义，有 <strong>等待</strong> 的意思，语法为：</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">myPromise</span><span class="p">();</span>
</code></pre></div></div>

<p>所谓 <strong>等待</strong> 其实就是指暂停当前 <code class="language-plaintext highlighter-rouge">async function</code> 内部语句的执行，等待后面的 <code class="language-plaintext highlighter-rouge">myPromise()</code> 处理完返回结果后，继续执行 <code class="language-plaintext highlighter-rouge">async function</code> 函数内部的剩余语句；<code class="language-plaintext highlighter-rouge">myPromise()</code> 是一个 Promise对象，而自定义的变量 <code class="language-plaintext highlighter-rouge">value</code> 则用于获取 Promise 对象返回的 <strong>resolve</strong> 状态值；</p>

<h2 id="用法">用法</h2>

<p>值得 <strong>注意</strong> 的是，<code class="language-plaintext highlighter-rouge">await</code> 必须在 <code class="language-plaintext highlighter-rouge">async function</code> 内使用，否则会提示语法错误；如果 await 后面跟的是其他值，则直接返回该值：</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nx">fn</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">await</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
            <span class="nx">resolve</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="p">},</span> <span class="mi">2000</span><span class="p">);</span>
    <span class="p">});</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">await</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">// 4 会被直接返回</span>
<span class="p">}</span>
<span class="nx">fn</span><span class="p">();</span>
<span class="c1">// 1</span>
<span class="c1">// 2 (2 秒后输出)</span>
<span class="c1">// 3</span>
<span class="c1">// 4</span>
</code></pre></div></div>

<p>如果不用获取返回值，也可以直接执行语句：</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nx">fn</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">await</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
            <span class="nx">resolve</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="p">},</span> <span class="mi">2000</span><span class="p">);</span>
    <span class="p">});</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">fn</span><span class="p">();</span>
<span class="c1">// 1</span>
<span class="c1">// 2 (2 秒后)</span>
<span class="c1">// 3</span>
</code></pre></div></div>

<h2 id="返回结果">返回结果</h2>

<p>如之前所说，await 会等到后面的 Promise <strong>返回结果</strong> 后才会执行 async 函数后面剩下的语句，也就是说如果 Promise 不返回结果（如 resolve 或 reject），后面的代码就不会执行，例如：</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nx">fn</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">await</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="p">},</span> <span class="mi">2000</span><span class="p">);</span>
    <span class="p">});</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">fn</span><span class="p">();</span>
<span class="c1">// 1</span>
<span class="c1">// 2 (2 秒后输出，并且后面不会继续输出 3)</span>
</code></pre></div></div>

<p>这里可以理解为函数会一直等待 await 返回结果（resolve / reject）才会执行剩下的语句，没有返回结果就会一直等下去，也就一直等不到剩下的语句执行了（还挺痴情-_-）；</p>

<p>如果 await 后面的 Promise 返回一个 <code class="language-plaintext highlighter-rouge">reject</code> 状态的结果的话，则会被当成错误在后台抛出，例如：</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nx">fn</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">await</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">reject</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="p">},</span> <span class="mi">2000</span><span class="p">);</span>
    <span class="p">});</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">fn</span><span class="p">();</span>
<span class="c1">// 1</span>
<span class="c1">// Uncaught (in promise) 2 (2 秒后输出)</span>
</code></pre></div></div>

<p>如上，2 秒后会抛出出错误，并且 3 这个数并没有被输出，说明后面的执行也被忽略了；</p>

<h2 id="匿名函数">匿名函数</h2>

<p>async 也可以用于申明匿名函数用于不同场景，或者嵌套使用 async 函数，如 <code class="language-plaintext highlighter-rouge">await async</code> 的形式，只是要在 await 后面使用 async 形式的函数的话，需要这个函数立即执行且有返回值；</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">fn</span> <span class="o">=</span> <span class="k">async</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">await</span> <span class="p">(</span><span class="k">async</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">})();</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>

    <span class="k">async</span> <span class="kd">function</span> <span class="nx">fn2</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">await</span> <span class="nx">fn2</span><span class="p">());</span>
<span class="p">}</span>
<span class="nx">fn</span><span class="p">();</span>
<span class="c1">// 1</span>
<span class="c1">// 2</span>
<span class="c1">// 3</span>
</code></pre></div></div>

<p>另外，await 后面的 Promise 返回的 reject， 也可以被该 async 函数返回的 Promise 对象以 reject 状态获取，例如：</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nx">fn</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">await</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">reject</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="p">},</span> <span class="mi">2000</span><span class="p">);</span>
    <span class="p">});</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">fn</span><span class="p">().</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
<span class="p">});</span>
<span class="c1">// 1</span>
<span class="c1">// 2 (2 秒后输出)</span>
</code></pre></div></div>

<p>这种情况就不会以错误抛出，直接对异常值进行了处理，并且最后同样没有输出数字 3，即后面的代码依然被忽略了；</p>

<h1 id="注意事项">注意事项</h1>

<h2 id="非-await-部分">非 await 部分</h2>

<p><code class="language-plaintext highlighter-rouge">async/await</code> 函数以同步的方式书写异步函数确实方便了不少场景，如定义所讲，函数内部遇到 <code class="language-plaintext highlighter-rouge">await</code> 会等到返回结果再继续执行下去，也就是说，非 await 部分仍然会以正常的异步或同步方式执行，例如遇到 <code class="language-plaintext highlighter-rouge">setTimeout()</code> 就会放入任务队列等待同步语句执行完后再执行；</p>

<p>比如以下情况：</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nx">fn</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    
    <span class="k">await</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
            <span class="nx">resolve</span><span class="p">();</span>
        <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>

    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">fn</span><span class="p">();</span>
<span class="c1">// 0</span>
<span class="c1">// 1（2 秒后）</span>
<span class="c1">// 3</span>
<span class="c1">// 2</span>
</code></pre></div></div>

<h2 id="await-内部">await 内部</h2>

<p>虽然说函数会等待 await 返回结果在继续执行，但是 await 内部的代码也依然按正常的同步和异步执行，例如：</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nx">fn</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    
    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">await</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>

        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

        <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
            <span class="nx">resolve</span><span class="p">();</span>
        <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>

        <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
        <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
    <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">fn</span><span class="p">();</span>
<span class="c1">// 0</span>
<span class="c1">// 3</span>
<span class="c1">// 1</span>
<span class="c1">// 2</span>
<span class="c1">// 5</span>
<span class="c1">// 4（2 秒后）</span>
<span class="c1">// 7</span>
<span class="c1">// 6</span>
</code></pre></div></div>

<p>上面的代码中返回结果的函数 <code class="language-plaintext highlighter-rouge">resolve()</code> 是在 <code class="language-plaintext highlighter-rouge">setTimeout()</code> 这个 <strong>异步任务</strong> 中，所以其被丢到事件队列中等待 2 秒再执行，由于此时 await 还未返回结果，所以还不会去执行 await 以外的代码（输出 7、6），而是先执行同为异步任务、但延时较短的输出 1、2、5 的代码；2 秒后结果返回了，就会继续正常执行 await 以外的同步任务和异步任务了；</p>

<p>但是假如 await 代码内返回结果的函数（resolve() 或 reject()）是在 <strong>同步任务</strong> 中执行的话，情况就有些不一样了，例如：</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nx">fn</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">await</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>

        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
        <span class="nx">resolve</span><span class="p">();</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>

        <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
        <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
    <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">fn</span><span class="p">();</span>
<span class="c1">// 0 </span>
<span class="c1">// 3</span>
<span class="c1">// 4</span>
<span class="c1">// 7</span>
<span class="c1">// 1</span>
<span class="c1">// 2</span>
<span class="c1">// 5</span>
<span class="c1">// 6</span>
</code></pre></div></div>

<p>由于同步任务 <strong>先于</strong> 异步任务执行的机理，在同步任务执行过程中依次输出了 0、3 后，就立即执行了 <code class="language-plaintext highlighter-rouge">resolve()</code> 使得 await 得到了返回结果，再往后就继续同步的输出了 4，但是输出 5 的代码是异步任务，与输出 1、2 的代码一并放入任务队列，此时由于 await 返回了结果，所以可以执行 await 以外的代码了，输出 6 是异步任务，于是先输出了同步任务的 7，同步任务都执行完了，最后执行任务队列中的异步任务，按之前进入队列的顺序，就是依次输出 1、2、5、6，所有代码运行结束；</p>

<h2 id="函数嵌套">函数嵌套</h2>

<p>当 async 函数中嵌套着其他 async 函数时，执行过程可能又有些和预想的不一样，先来看下面的例子：</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nx">fn</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>

    <span class="p">(</span><span class="k">async</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    
        <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
        <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>

        <span class="k">await</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">res</span> <span class="o">=&gt;</span> <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="mi">1000</span><span class="p">))</span>

        <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
        <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>

        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="p">})()</span>

    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">fn</span><span class="p">();</span>
<span class="c1">// 0</span>
<span class="c1">// 2</span>
<span class="c1">// 6</span>
<span class="c1">// 1</span>
<span class="c1">// 3</span>
<span class="c1">// 5（1 秒后）</span>
<span class="c1">// 4（再等 1 秒后）</span>
</code></pre></div></div>

<p>也许会疑惑，不是说 async 函数会等到 await 返回结果后再继续执行吗，为何就先输出 6 了？其实不要混淆概念，确实 async 函数内部是这样干的（3 后 1秒输出 5、4），但 async 函数它自身执行时依然是正常的同步任务执行，也就是虽然内部的 async 函数会等待其 await 返回结果才继续执行后面的代码，但外部的 async 函数可不会等待内部的那个 await，会照常执行（你不是我的菜，天涯何处无芳草╮(╯▽╰)╭）；</p>

<p>如果确实需要等待这个嵌套的 async 函数执行完再执行剩下的代码，那么前面加个 await 就行了，原理是也是可行的，因为 async 函数就是返回的一个 Promise 函数，代码如下：</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nx">fn</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">await</span> <span class="p">(</span><span class="k">async</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    
        <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
        <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>

        <span class="k">await</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">res</span> <span class="o">=&gt;</span> <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="mi">1000</span><span class="p">))</span>

        <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
        <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>

        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="p">})()</span>

    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">fn</span><span class="p">();</span>
<span class="c1">// 0</span>
<span class="c1">// 2</span>
<span class="c1">// 1</span>
<span class="c1">// 3</span>
<span class="c1">// 5（1 秒后）</span>
<span class="c1">// 6</span>
<span class="c1">// 4（再等 1 秒后）</span>
</code></pre></div></div>

<p>这里也要 <strong>注意</strong>，假如嵌套的 async 函数中的 await 不返回结果，并且没有在嵌套的 async 函数前面添加 await，那么外部的 async 函数内部剩余的代码也不会执行；</p>

    </div>
</div>
<hr>

<!-- valine 评论插件 -->
<h3>评论：</h3>
<div class="comments"></div>
<hr>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '.comments',
        appId: '4XY3DoTJmibNe3rHeAKOxqzl-gzGzoHsz',
        appKey: 'vjothQHALvgTQF9GrSgj577a',
        avatar: 'robohash',
        placeholder: '留下你的评论吧（支持Markdown）~',
        // visitor: true,
    })
</script>

<!-- 微信公众号 -->
<div class="program-knight">
    <p>技术文章推送</p>
    <p>手机、电脑实用软件分享</p>
    <img src="/assets/img/knight.png" alt="微信搜索公众号: 程序骑士" title="微信搜索公众号: 程序骑士">
    <div>
        <img src="/assets/img/wechat.png" alt="wechat">
        <b>微信公众号：程序骑士</b>
    </div>
</div>
<!--百度资源自动提交-->


    </div>
</div>

</main>

<footer class="page-footer teal">
    <div class="container">
        <div class="row">
            <div class="col s12">
                <p class="footer-message grey-text text-lighten-3">以勤劳的双手，用心敲写明天</p>
                <hr>
                <p class="visit-statistics">
                    <span id="busuanzi_container_site_pv">访问量：<span id="busuanzi_value_site_pv"></span>次</span>&nbsp;
                    <span id="busuanzi_container_site_pv">访客量：<span id="busuanzi_value_site_uv"></span>人次</span>
                </p>
                <p class="grey-text text-lighten-4">基于 jekyll 的 Github Pages 个人博客网站
</p>
            </div>
        </div>
    </div>
    <div class="footer-copyright">
        <div class="container">
            Copyright &#xA9; 2021 苏梓鑫的博客. All rights reserved. Powered by
            <a href=https://github.com/suzixin/suzixin.github.io>knightyun</a>.
        </div>
    </div>
    <!-- Search box -->
    <div class="search">
        <i class="material-icons search-icon search-start">search</i>
        <input type="text" class="search-input" placeholder="Searching...（支持正则表达式）" />
        <i class="material-icons search-icon search-clear">clear</i>
        <div class="search-results z-depth-4"></div>
    </div>
    <!-- 右下角功能按钮 -->
    <div class="fixed-action-btn">
        <a class="btn-floating btn-large blue z-depth-4">
            <i class="large material-icons">apps</i>
        </a>
        <ul>
            <li class="category-btn hide">
                <!-- 文章目录按钮 -->
                <a class="sidenav-trigger btn-floating blue lighten-2" data-target="category">
                    <i class="material-icons">format_list_bulleted</i>
                </a>
            </li>
            <li>
                <a class="btn-floating blue lighten-2" href="javascript: searchInput.focus()">
                    <i class="material-icons">search</i>
                </a>
            </li>
            <li>
                <a class="btn-floating blue lighten-2" href="javascript: scrollTo(0, 0);">
                    <i class="material-icons">publish</i>
                </a>
            </li>
            <li>
                <a class="btn-floating blue lighten-2" href="javascript: scrollTo(0, document.body.clientHeight);">
                    <i class="material-icons">file_download</i>
                </a>
            </li>
        </ul>
    </div>
    <!-- 文章目录侧栏 -->
    <ul id="category" class="hide sidenav no-autoinit grey lighten-4 grey-text text-darken-3">
        <li>
            <p class="center-align">目录</p>
        </li>
    </ul>
</footer>


    
    <script src="/assets/js/min/materialize.min.js"></script>
    

    
    <script src="/assets/js/min/post.min.js"></script>
    

    
    <script src="/assets/js/min/particles.min.js"></script>
    

    
    <script src="/assets/js/min/main.min.js"></script>
    

    
    <script src="/assets/js/min/search.min.js"></script>
    

    
    <script src="/assets/js/min/gen-category.min.js"></script>
    




<!-- 以下为插入的第三方网站分析代码 -->

</body>

</html>