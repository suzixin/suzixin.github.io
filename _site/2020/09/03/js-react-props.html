<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=gb2312" />
    <meta http-equiv="Content-Language" content="zh-CN" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- 360 -->
    <meta name="360-site-verification" content="fa6ca3a9a0330e9cecabee0a9fe1d52a" />
    <!-- 搜狗 -->
    <meta name="sogou_site_verification" content="oatSp9uAV5" />
    <!--熊掌号 -->
    <meta name="baidu-site-verification" content="Wkb0Jzk8yx" />
    <!-- Google Search Console -->
    <meta name="google-site-verification" content="IJrXvaK-Luj-lCGP7tymcCbkcfMKi82Y8V21qN9ZT0s" />
    <title>
        
            React 组件间传值的几种情形
        
    </title>
    <link rel="shortcut icon" type="image/x-icon" href="/assets/img/favicon.ico">
    
    <link rel="stylesheet" href="/assets/css/materialize.min.css">
    <link rel="stylesheet" href="/assets/css/icons.css">
    

    
        
        <link rel="stylesheet" href="/assets/css/page.css">
        
    
        
        <link rel="stylesheet" href="/assets/css/post.css">
        
    
        
        <link rel="stylesheet" href="/assets/css/syntax.css">
        
    
        
        <link rel="stylesheet" href="/assets/css/article-category.css">
        
    

    
    <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml">
    <link rel="sitemap" type="application/xml" title="Sitemap" href="/sitemap.xml">	
    <!-- Begin Jekyll SEO tag v2.7.1 -->
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="React 组件间传值的几种情形" />
<meta property="og:locale" content="zh_CN" />
<meta name="description" content="举例介绍 React 中组件间传值的几种情景" />
<meta property="og:description" content="举例介绍 React 中组件间传值的几种情景" />
<link rel="canonical" href="http://localhost:4000/2020/09/03/js-react-props" />
<meta property="og:url" content="http://localhost:4000/2020/09/03/js-react-props" />
<meta property="og:site_name" content="苏梓鑫的博客" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-09-03T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="React 组件间传值的几种情形" />
<script type="application/ld+json">
{"url":"http://localhost:4000/2020/09/03/js-react-props","headline":"React 组件间传值的几种情形","dateModified":"2020-09-03T00:00:00+08:00","datePublished":"2020-09-03T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2020/09/03/js-react-props"},"description":"举例介绍 React 中组件间传值的几种情景","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body>
    <header>
        <nav class="top-nav">
            
            <div class="nav-wrapper">
                <div class="container">
                    
                    <a class="page-title" href="/">苏梓鑫的博客</a>
                    <p class="head-message">学习&nbsp;&nbsp;总结&nbsp;&nbsp;分享&nbsp;&nbsp;提升</p>
                </div>
            </div>
        </nav>

        <div class="container">
            <a href="#" data-target="slide-out" class="sidenav-trigger top-nav full hide-on-large-only">
                <i class="material-icons">menu</i>
            </a>
        </div>
        <ul id="slide-out" class="sidenav sidenav-fixed" style="background-color:#ddd">
            <li>
                <div class="userView">
                    <img class="user-bg" src="/assets/img/bg.png" />
                    <a class="user-avatar" href="https://github.com/suzixin" target="_blank">
                        <img class="circle z-depth-2" src="/assets/img/user.png" width="64" />
                    </a>
                    <div class="white-text user-info">
                        苏梓鑫 <i>(Knight Huang)</i><br>
                        adahsuzixin@gmail.com
                    </div>
                </div>
            </li>
            <li><a class="waves-effect" href="/"><i class="material-icons">home</i>Home - 主页</a></li>
            <li><a class="waves-effect" href="/projects"><i class="material-icons">description</i>Github - 项目</a></li>
            <li><a class="waves-effect" href="/categories"><i class="material-icons">sort</i>Categories - 目录</a></li>
            <li><a class="waves-effect" href="/tags"><i class="material-icons">label</i>Tags - 标签</a></li>
            <li><a class="waves-effect" href="/feed.xml" target="_blank"><i class="material-icons">rss_feed</i>RSS - 订阅</a></li>
            <li><a class="waves-effect" href="/about"><i class="material-icons">person</i>About - 关于我</a></li>
            <li><a class="waves-effect" href="/contact"><i class="material-icons">email</i>Contact - 联系我</a></li>
            <!-- 华为云广告 -->
            <li class="ad">
                <!-- <a href="https://mp.weixin.qq.com/s/ujUoHc3grjO8LD_Bg1fckA" target="_blank"> -->
                <!-- <a href="https://mp.weixin.qq.com/s/MTbMlhjAx8R4fc8Po90EXg" target="_blank">
                    <img src="/assets/img/ad-huaweiyun.png" alt="" width="100%" />
                </a>
                <i class="material-icons" onclick="javascript:this.parentNode.style.display='none';">close</i> -->
            </li>
        </ul>
    </header>
    <main>

<div class="container">
    <div id="page-info">
        <h1 class="page-title white-text">React 组件间传值的几种情形</h1>
    </div>
    <div id="page-content" class="row">
        <div id="post-info">
    <ul class="collapsible hoverable" data-collapsible="accordion">
        <li>
            <div class="collapsible-header grey lighten-4">
                <span>
                    <i class="material-icons tooltipped" data-position="left" data-delay="30" data-tooltip="Date">date_range</i>
                    03/09/2020 00:00<br />
                    <div id="busuanzi_container_site_pv">点击量：<span style="display: inline;" id="busuanzi_value_page_pv"></span>次</div>
                    <i id="indicate" class="right material-icons tooltipped" data-position="left" data-delay="30"
                        data-tooltip="Show extra info">info</i>
                </span>
            </div>
            <div class="collapsible-body">
                <span>
                    <i class="material-icons tooltipped" data-position="left" data-delay="30" data-tooltip="Categories">sort</i>
                    
                    
                    
                    <a href="/categories#javascript_cap"
                        target="_blank">
                        <div class="chip">JavaScript</div>
                    </a>
                    
                </span>
                <span>
                    <i class="material-icons tooltipped" data-position="left" data-delay="30" data-tooltip="Tags">label</i>
                    
                    
                    
                    <a href="/tags#react" target="_blank">
                        <div class="chip">react</div>
                    </a>
                    
                    
                    
                    <a href="/tags#组件_cap" target="_blank">
                        <div class="chip">组件</div>
                    </a>
                    
                    
                    
                    <a href="/tags#props" target="_blank">
                        <div class="chip">props</div>
                    </a>
                    
                    
                    
                    <a href="/tags#ref" target="_blank">
                        <div class="chip">ref</div>
                    </a>
                    
                    
                    
                    <a href="/tags#context" target="_blank">
                        <div class="chip">context</div>
                    </a>
                    
                </span>
            </div>
        </li>
    </ul>
</div>
<div class="divider"></div>
<div id="post-content" class="row">
    <div class="col s12">
        <h2 id="父级传向子级">父级传向子级</h2>

<p>这应该是最常见的一种场景，通过在子组件上写 <code class="language-plaintext highlighter-rouge">props</code>，将数据从父组件中传递到子组件，子组件再从 <code class="language-plaintext highlighter-rouge">this.props</code> 中获取相应的值，这样可以根据传入值的不同返回不同的状态，即实现组件的复用；例如：</p>
<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span><span class="p">;</span>

<span class="c1">// 父组件</span>
<span class="kd">class</span> <span class="nx">Parent</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
    <span class="nx">message</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Hello world!</span><span class="dl">'</span><span class="p">;</span>

    <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">&lt;</span><span class="nc">Child</span> <span class="na">myProp</span><span class="p">=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">message</span><span class="si">}</span> <span class="p">/&gt;</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 子组件</span>
<span class="kd">class</span> <span class="nx">Child</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
    <span class="nx">message</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">myProp</span><span class="p">;</span>

    <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// Hello world!</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">message</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">Parent</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="多层传值">多层传值</h3>

<p>上述方法只用于单层数据传递，即父级传向子级，如果子级又存在子级，甚至向下递推，那么父组件要传值给后代组件，就要逐层向下传递，类似下面的情况：</p>
<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">class</span> <span class="nx">Parent</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
    <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">&lt;</span><span class="nc">Child</span> <span class="na">myProp</span><span class="p">=</span><span class="s">"hello"</span> <span class="p">/&gt;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Child</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
    <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">&lt;</span><span class="nc">Grandchild</span> <span class="na">myProp1</span><span class="p">=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">myProp</span><span class="si">}</span> <span class="p">/&gt;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Grandchild</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
    <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// hello</span>
        <span class="k">return</span> <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">myProp1</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">Parent</span><span class="p">;</span>
</code></pre></div></div>

<p>如果层数再多一些就是书写噩梦了，所以 React 提供了 <code class="language-plaintext highlighter-rouge">context</code> 机制，解决了深层传值的问题，现在来改造上面的代码：</p>
<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">Reac</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span><span class="p">;</span>

<span class="c1">// 首先需要创建一个自定义 context</span>
<span class="c1">// 该方法接收一个参数作为 context 的默认值</span>
<span class="kd">const</span> <span class="nx">myContext</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createContext</span><span class="p">();</span>
<span class="c1">// 获取包裹组件，用于包裹需要应用 context 的组件</span>
<span class="kd">const</span> <span class="p">{</span> <span class="nx">Provider</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">myContext</span><span class="p">;</span>

<span class="kd">class</span> <span class="nx">Parent</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
    <span class="nx">value</span> <span class="o">=</span> <span class="p">{</span>
        <span class="na">message</span><span class="p">:</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">,</span>
    <span class="p">};</span>
    
    <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 通过包裹器的 value 属性向下传递指定值</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">&lt;</span><span class="nc">Provider</span> <span class="na">value</span><span class="p">=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="si">}</span><span class="p">&gt;</span>
                <span class="p">&lt;</span><span class="nc">Child</span> <span class="p">/&gt;</span>
            <span class="p">&lt;/</span><span class="nc">Provider</span><span class="p">&gt;</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Child</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
    <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">&lt;</span><span class="nc">Grandchild</span> <span class="p">/&gt;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Grandchild</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
    <span class="c1">// 在需要获取祖代传递的 context 值的后代组件中，</span>
    <span class="c1">// 声明 contextType 静态属性，值为之前创建的 context;</span>
    <span class="kd">static</span> <span class="nx">contextType</span> <span class="o">=</span> <span class="nx">myContext</span><span class="p">;</span>
    
    <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 最后使用 this.context 就能获取到之前</span>
        <span class="c1">// 在 Provider 中传入的 value 值；</span>
        <span class="k">return</span> <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">.</span><span class="nx">message</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
        <span class="c1">// hello</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">Parent</span><span class="p">;</span>
</code></pre></div></div>

<p>需要注意的是，由于提供方和调用方需要使用同一个使用 <code class="language-plaintext highlighter-rouge">React.createContext()</code> 创建的 <code class="language-plaintext highlighter-rouge">context</code>，所以如果父组件和要调用 context 的子组件不在同一个文件中的话，则需要考虑通过 <code class="language-plaintext highlighter-rouge">export</code> 和 <code class="language-plaintext highlighter-rouge">import</code> 来实现引用，但是这样组件间的耦合度又增加了一层，React 官方建议使用 <strong>组合</strong> 方式取代上述的 <strong>继承</strong> 方式，下面再次对上述代码进行改造：</p>
<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">class</span> <span class="nx">Parent</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
    <span class="nx">value</span> <span class="o">=</span> <span class="p">{</span>
        <span class="na">message</span><span class="p">:</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">&lt;</span><span class="nc">Child</span><span class="p">&gt;</span>
                <span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">message</span><span class="si">}</span>
            <span class="p">&lt;/</span><span class="nc">Child</span><span class="p">&gt;</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Child</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
    <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// this.props.children 会指向父组件在子组件中嵌入的数据或组件</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">children</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">Parent</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="子级传向父级">子级传向父级</h2>

<p>React 中似乎没有提供子级向父级直接传值，类似 <code class="language-plaintext highlighter-rouge">props</code> 的方法或途径，可以通过一些间接手段实现，开发中常见的处理方式就是子组件调用父组件通过 <code class="language-plaintext highlighter-rouge">props</code> 传入的处理函数，对需要传递的值进行处理；例如：</p>
<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">class</span> <span class="nx">Parent</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
    <span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
        <span class="na">message</span><span class="p">:</span> <span class="dl">''</span><span class="p">,</span>
    <span class="p">};</span>
    
    <span class="nx">handleMsg</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span>
            <span class="na">message</span><span class="p">:</span> <span class="nx">msg</span><span class="p">,</span>
        <span class="p">});</span>
    <span class="p">}</span>
    
    <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// Hello</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">&lt;&gt;</span>
                <span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">message</span><span class="si">}</span>
                <span class="p">&lt;</span><span class="nc">Child</span> 
                    <span class="na">onMsg</span><span class="p">=</span><span class="si">{</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">handleMsg</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span><span class="si">}</span>
                <span class="p">/&gt;</span>
            <span class="p">&lt;/&gt;</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Child</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
    <span class="nx">handleClick</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">onMsg</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">&lt;</span><span class="nt">button</span>
                <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">handleClick</span><span class="p">()</span><span class="si">}</span>
            <span class="p">&gt;</span>Clike me<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">Parent</span><span class="p">;</span>
</code></pre></div></div>

<p>简单梳理一下流程：</p>
<ul>
  <li>父组件提前声明数据处理逻辑，该方法接收传入的值，然后进行相应处理；</li>
  <li>父组件将该方法通过 props 传递给子组件；</li>
  <li>子组件触发一些行为，得到了将要传递给父组件的值；</li>
  <li>子组件通过 <code class="language-plaintext highlighter-rouge">this.props</code> 调用父组件传入的处理函数，并将要传递的值作为该函数的参数；</li>
  <li>处理函数开始执行，由于其是在父组件的作用域中声明的，所以也能访问父组件中的一些数据，比如 <code class="language-plaintext highlighter-rouge">state</code>，相当于在父组件中处理子组件传入的数据；</li>
  <li>处理函数更新 state 状态值，随后其他访问该 state 的地方也会随即更新；</li>
</ul>

<h2 id="同级间传递">同级间传递</h2>

<h3 id="状态提升">状态提升</h3>

<p>这是 React 官网提到的一个概念，即多个组件都在重复使用同一个状态值，可以将这个值 <strong>提升</strong> 至父组件中保存，相当于数据复用；当然如果想实现一个子组件向另一个子组件传值，也可以通过父组件这层“媒介”；下面举例说明：</p>
<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">class</span> <span class="nx">Parent</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
    <span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
        <span class="na">msg</span><span class="p">:</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">,</span>
    <span class="p">}</span>
    
    <span class="nx">handleChangeMsg</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span>
            <span class="na">msg</span><span class="p">:</span> <span class="nx">msg</span><span class="p">,</span>
        <span class="p">});</span>
    <span class="p">}</span>
    
    <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(&lt;&gt;</span>
            <span class="p">&lt;</span><span class="nc">ChildLabel</span> <span class="na">msg</span><span class="p">=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">msg</span><span class="si">}</span> <span class="p">/&gt;</span>
            <span class="p">&lt;</span><span class="nc">ChildButton</span>
                <span class="na">onChangeMsg</span><span class="p">=</span><span class="si">{</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">handleChangeMsg</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span><span class="si">}</span>
            <span class="p">/&gt;</span>
        <span class="p">&lt;/&gt;);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">ChildLabel</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
    <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">msg</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">ChildButton</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
    <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">&lt;</span><span class="nt">button</span>
                <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">onChangeMsg</span><span class="p">(</span><span class="dl">'</span><span class="s1">world</span><span class="dl">'</span><span class="p">)</span><span class="si">}</span>
            <span class="p">&gt;</span>Change<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
        <span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">Parent</span><span class="p">;</span>
</code></pre></div></div>

<p>这样在页面中点击子组件 <code class="language-plaintext highlighter-rouge">&lt;ChildButton /&gt;</code> 中的按钮时，子组件 <code class="language-plaintext highlighter-rouge">&lt;ChildLabel /&gt;</code> 中的文本便会发生相应变化，成功获取传入的值；这里的操作相当于子组件先向父组件传值，使得父组件状态变化，然后使用该状态的另一子组件就会相应地变化；</p>

<h3 id="refs">Refs</h3>

<p><code class="language-plaintext highlighter-rouge">Refs</code> 是 React 提供的另一种机制，React 中典型数据流是通过 <code class="language-plaintext highlighter-rouge">props</code> 传递，而 refs 则相当于提供了直接操纵组件或 DOM 元素的一种途径，强制修改元素；因此官网也建议避免过度使用 refs，防止应用变得难以理解或“失控”；下面通过举例简单说明其用法：</p>
<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">class</span> <span class="nx">Parent</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
    <span class="c1">// 首先需要声明 ref</span>
    <span class="nx">myRef</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createRef</span><span class="p">();</span>
    
    <span class="nx">handleClick</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 通过 ref 的 current 属性实现对该元素的引用，</span>
        <span class="c1">// 然后就能想操作正常 DOM 一样实现控制；</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">myRef</span><span class="p">.</span><span class="nx">current</span><span class="p">.</span><span class="nx">innerText</span> <span class="o">=</span> <span class="nx">msg</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 对需要被引用的元素使用 ref 属性，值为之前所创建的 ref</span>
        <span class="k">return</span> <span class="p">(&lt;&gt;</span>
            <span class="p">&lt;</span><span class="nt">span</span> <span class="na">ref</span><span class="p">=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">myRef</span><span class="si">}</span><span class="p">&gt;</span>hello<span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">button</span>
                <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">handleClick</span><span class="p">(</span><span class="dl">'</span><span class="s1">world</span><span class="dl">'</span><span class="p">)</span><span class="si">}</span>
            <span class="p">&gt;</span>Change<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
        <span class="p">&lt;/&gt;);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">Parent</span><span class="p">;</span>
</code></pre></div></div>

<p>在页面上点击按钮后，前面的文本同样会发生改变，即 DOM 元素的元素属性 <code class="language-plaintext highlighter-rouge">innerText</code> 值被成功修改，如需使用其他原生属性或方法同理；</p>

<h3 id="refs-转发">Refs 转发</h3>

<p>虽然 <code class="language-plaintext highlighter-rouge">Refs</code> 提供了直接访问组件或元素的途径，但是它却访问不了<strong>组件中的组件</strong>，这是 React 层故意为之，隐藏组件实现细节与渲染结果，防止组件的 DOM 结构被过度依赖；但有一些特殊情况下确实需要访问组件内部的组件的话，React 也提供了另外一种机制，即 <strong>Refs 转发（Refs Forwarding）</strong>；顾名思义，组件 A 不能直接使用 <code class="language-plaintext highlighter-rouge">ref</code> 访问组件 B 中的组件 C，但是可以通过组件 B 转发 <code class="language-plaintext highlighter-rouge">ref</code> 给组件 C，这里改造一下上面 <code class="language-plaintext highlighter-rouge">Refs</code> 中的例子，我们在 <code class="language-plaintext highlighter-rouge">&lt;Parent /&gt;</code> 和 <code class="language-plaintext highlighter-rouge">&lt;span&gt;</code> 之间再加一层组件，再实现对其的操作：</p>
<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Parent</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
    <span class="nx">myRef</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createRef</span><span class="p">();</span>
    
    <span class="nx">handleClick</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">myRef</span><span class="p">.</span><span class="nx">current</span><span class="p">.</span><span class="nx">innerText</span> <span class="o">=</span> <span class="nx">msg</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 对子组件正常使用 ref</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">&lt;</span><span class="nc">Child</span>
                <span class="na">ref</span><span class="p">=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">myRef</span><span class="si">}</span>
                <span class="na">handleClick</span><span class="p">=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">handleClick</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">)</span><span class="si">}</span>
            <span class="p">/&gt;</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 使用 React.forwardRef 方法转发 ref 给下一层组件</span>
<span class="kd">const</span> <span class="nx">Child</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">forwardRef</span><span class="p">((</span><span class="nx">props</span><span class="p">,</span> <span class="nx">ref</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(&lt;&gt;</span>
        <span class="p">&lt;</span><span class="nt">span</span> <span class="na">ref</span><span class="p">=</span><span class="si">{</span><span class="nx">ref</span><span class="si">}</span><span class="p">&gt;</span>hello<span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">button</span>
            <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">props</span><span class="p">.</span><span class="nx">handleClick</span><span class="p">(</span><span class="dl">'</span><span class="s1">world</span><span class="dl">'</span><span class="p">)</span><span class="si">}</span>
        <span class="p">&gt;</span>Change<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
    <span class="p">&lt;/&gt;);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>Refs 转发需要使用 <code class="language-plaintext highlighter-rouge">React.forwardRef()</code> 方法创造组件，该方法接收一个回调函数做为参数，该回调函数接收两个入参，第一个是传进组件的 <code class="language-plaintext highlighter-rouge">props</code>，第二个是传进组件的的 <code class="language-plaintext highlighter-rouge">ref</code>，通过内部逻辑决定 <code class="language-plaintext highlighter-rouge">ref</code> 再转发给谁，回调函数的返回值是最终生成的组件；页面加载组件后，点击按钮，就能像直接使用 <code class="language-plaintext highlighter-rouge">ref</code> 一样改变展示的文本值了；</p>

    </div>
</div>
<hr>

<!-- valine 评论插件 -->
<h3>评论：</h3>
<div class="comments"></div>
<hr>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '.comments',
        appId: '4XY3DoTJmibNe3rHeAKOxqzl-gzGzoHsz',
        appKey: 'vjothQHALvgTQF9GrSgj577a',
        avatar: 'robohash',
        placeholder: '留下你的评论吧（支持Markdown）~',
        // visitor: true,
    })
</script>

<!-- 微信公众号 -->
<div class="program-knight">
    <p>技术文章推送</p>
    <p>手机、电脑实用软件分享</p>
    <img src="/assets/img/knight.png" alt="微信搜索公众号: 程序骑士" title="微信搜索公众号: 程序骑士">
    <div>
        <img src="/assets/img/wechat.png" alt="wechat">
        <b>微信公众号：程序骑士</b>
    </div>
</div>
<!--百度资源自动提交-->


    </div>
</div>

</main>

<footer class="page-footer teal">
    <div class="container">
        <div class="row">
            <div class="col s12">
                <p class="footer-message grey-text text-lighten-3">以勤劳的双手，用心敲写明天</p>
                <hr>
                <p class="visit-statistics">
                    <span id="busuanzi_container_site_pv">访问量：<span id="busuanzi_value_site_pv"></span>次</span>&nbsp;
                    <span id="busuanzi_container_site_pv">访客量：<span id="busuanzi_value_site_uv"></span>人次</span>
                </p>
                <p class="grey-text text-lighten-4">基于 jekyll 的 Github Pages 个人博客网站
</p>
            </div>
        </div>
    </div>
    <div class="footer-copyright">
        <div class="container">
            Copyright &#xA9; 2021 苏梓鑫的博客. All rights reserved. Powered by
            <a href=https://github.com/suzixin/suzixin.github.io>knightyun</a>.
        </div>
    </div>
    <!-- Search box -->
    <div class="search">
        <i class="material-icons search-icon search-start">search</i>
        <input type="text" class="search-input" placeholder="Searching...（支持正则表达式）" />
        <i class="material-icons search-icon search-clear">clear</i>
        <div class="search-results z-depth-4"></div>
    </div>
    <!-- 右下角功能按钮 -->
    <div class="fixed-action-btn">
        <a class="btn-floating btn-large blue z-depth-4">
            <i class="large material-icons">apps</i>
        </a>
        <ul>
            <li class="category-btn hide">
                <!-- 文章目录按钮 -->
                <a class="sidenav-trigger btn-floating blue lighten-2" data-target="category">
                    <i class="material-icons">format_list_bulleted</i>
                </a>
            </li>
            <li>
                <a class="btn-floating blue lighten-2" href="javascript: searchInput.focus()">
                    <i class="material-icons">search</i>
                </a>
            </li>
            <li>
                <a class="btn-floating blue lighten-2" href="javascript: scrollTo(0, 0);">
                    <i class="material-icons">publish</i>
                </a>
            </li>
            <li>
                <a class="btn-floating blue lighten-2" href="javascript: scrollTo(0, document.body.clientHeight);">
                    <i class="material-icons">file_download</i>
                </a>
            </li>
        </ul>
    </div>
    <!-- 文章目录侧栏 -->
    <ul id="category" class="hide sidenav no-autoinit grey lighten-4 grey-text text-darken-3">
        <li>
            <p class="center-align">目录</p>
        </li>
    </ul>
</footer>


    
    <script src="/assets/js/min/materialize.min.js"></script>
    

    
    <script src="/assets/js/min/post.min.js"></script>
    

    
    <script src="/assets/js/min/particles.min.js"></script>
    

    
    <script src="/assets/js/min/main.min.js"></script>
    

    
    <script src="/assets/js/min/search.min.js"></script>
    

    
    <script src="/assets/js/min/gen-category.min.js"></script>
    




<!-- 以下为插入的第三方网站分析代码 -->

</body>

</html>